<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>JavaScript 基础</title>
        <link rel="stylesheet" href="../../assets/fonts.css">
        <link rel="stylesheet" href="../../assets/graphite.css">
        <link rel="stylesheet" href="../../assets/pygments.css">
        <script src="../../assets/image-zoom.js" defer></script>
        
        
    </head>
    <body class="node-articles-javascript-1 node-articles-javascript node-articles node">
        <header class="masthead">
            <h1><a href="../../index.html">Oasis's Cloud</a></h1>
            
                <p class="tagline">一个人的首要责任，就是要有雄心。雄心是一种高尚的激情，它可以采取多种合理的形式。<br />—— 《一个数学家的辩白》</p>
            
            
            <nav class="menu">
                <input id="menu-check" type="checkbox"/>
                <label id="menu-label" for="menu-check" class="unselectable">
                    <span class="icon close-icon">✕</span>
                    <span class="icon open-icon">☰</span>
                    <span class="text">Menu</span>
                </label>
                <ul>
<li><a href="../../index.html">首页</a></li>
</ul>
            </nav>
        </header>
        <article class="main">
            <header class="title">
                <h1>JavaScript 基础</h1>
                
                
                    <p class="author">作者：oasis</p>
                
                <hr>
            </header>
            <h2>&ldquo;use strict&rdquo;</h2>
<p>&ldquo;use strict&rdquo; 可以明确地激活 ES5 新增的特性和一些被修改过的特性。</p>
<p>&ldquo;use strict&rdquo; 可以放在脚本最顶部。
放在脚本的最顶部，则整个文件都以现代模式工作。</p>
<h2>变量</h2>
<p>JS 中变量声明可以通过 var、let、const，</p>
<p>var 声明的变量存在变量提升，如下例子
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// undefined</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// 1</span>
<span class="p">}</span>
</code></pre></div>
通过 let 声明的变量不存在提升。</p>
<div class="highlight"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">a</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// Uncaught ReferenceError: Cannot access &#39;b&#39; before initialization</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// 1</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">()</span>
</code></pre></div>
<p>在 if 等语句中通过 var 声明的变量可以在程序中的其他地方使用，例如：
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10</span>
<span class="p">}</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">say</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="c1">// 10</span>
<span class="p">}</span>
</code></pre></div>
通过 let 和 const 声明的变量则存在块级作用域的限制。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10</span>
<span class="p">}</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">say</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="c1">// a is not defined</span>
<span class="p">}</span>
</code></pre></div>
<p>通过 var 声明变量的话可以重复声明。而 let 和 const 不可以。</p>
<p>const 表示声明一个常量，而且要声明和初始化一起。否则会报错。</p>
<p>const 声明并初始化一个数组或对象，我们可以修改数组的元素或对象属性的值。这里的深层原因是 const 保留的是数组或对象的指针，仅仅是确保指针不变。</p>
<p>如何声明不可修改的对象呢？可以通过 Object.defineProperty()
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;property1&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="mf">42</span><span class="p">,</span>
<span class="w">  </span><span class="nx">writable</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span>
<span class="p">});</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">property1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="w"> </span><span class="c1">// {property1: 42}</span>
</code></pre></div></p>
<h2>类型</h2>
<p>首先思考为什么编程语言中提供了类型这种抽象，类型帮助我们解决了什么问题？</p>
<ul>
<li>类型解决了数据存的问题：通过不同的类型，编译器可以开辟不同的内存大小，解决数据如何存的问题。</li>
<li>类型解决了数据取的问题：由于内存中的数据本没有意义，而是通过人为的界定数据才有了实际的意义，比如内存中同样的 4 个字节，存放着同样的二进制码，如果这两块内存对应的两个变量类型不一样，那么它们意义就不一样了。</li>
</ul>
<p>JS 中主要提供了如下类型：</p>
<ul>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>null</li>
<li>undefined</li>
<li>symbol</li>
<li>bigint</li>
<li>object</li>
</ul>
<p>在 JS 中 函数和正则都属于 object 类型，数组也属于 object 类型。</p>
<h3>类型转换</h3>
<p>转换算法是：</p>
<ul>
<li>调用 obj<a href="hint">Symbol.toPrimitive</a> 如果这个方法存在，</li>
<li>否则，如果 hint 是 &ldquo;string&rdquo;</li>
<li>尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。</li>
<li>否则，如果 hint 是 &ldquo;number&rdquo; 或者 &ldquo;default&rdquo;</li>
<li>尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。</li>
</ul>
<h3>null 和 undefined 的却别</h3>
<ul>
<li>null 代表“无”、“空”或“值未知”的特殊值，undefined 表示未被赋值</li>
<li>typeof null 返回 object，typeof undefined 返回 undefined</li>
<li>null === null // true</li>
<li>undefined === undefined // ture</li>
<li>undefined === null // false</li>
</ul>
<h3>number 类型注意点</h3>
<ul>
<li>0.1 + 0.2 === 0.3 // false</li>
<li>NaN == NaN // false</li>
<li>NaN === Nan // false</li>
</ul>
<p>NaN 表示不是一个数字，比如做显示类型转换的时候可能会得到这个结果。 Number(0/0)</p>
<h3>数组的检测</h3>
<ul>
<li><code>Array.isArray()</code></li>
<li><code>Object.prototype.toString.call([])</code>，解释原理：</li>
</ul>
<h3>Object 类型</h3>
<h4>对象的创建</h4>
<ul>
<li>可通过对象字面量创建</li>
<li>可通过 new 关键字创建</li>
<li>new 关键字的过程如下<ul>
<li>一个新的空对象被创建并分配给 this。</li>
<li>函数体执行。通常它会修改 this，为其添加新的属性。</li>
<li>返回 this 的值。</li>
</ul>
</li>
<li>可通过 Object.create() 创建，使用 Object.create(null) 创建原型为 null 的对象。相当于使用 <code>{__proto__: null}</code></li>
</ul>
<h4>对象的继承</h4>
<ul>
<li>
<p>通过 <code>Object.create()</code> 实现继承</p>
</li>
<li>
<p>通过 <code>prototype</code> 实现继承</p>
</li>
<li>
<p>通过 <code>mixin</code> 实现继承</p>
</li>
</ul>
<h4><code>__proto__</code> 和  <code>prototype</code> 的区别</h4>
<p><code>__proto__</code>用于设置对象的原型</p>
<h4><code>for .. in</code> 和 <code>for ... of</code> 区别</h4>
<ul>
<li>for..in 会跳过 symbol</li>
<li>for..in 会遍历出原型链上的属性</li>
<li>for..of 用与可迭代对象，通过 for&hellip;of 和 Symbo.iterator 的配合，可以对 JS 中的很多数据结构进行统一的迭代处理</li>
</ul>
<h4>symbol</h4>
<p>表示唯一标识，for..in 会跳过 symbol。Object.assign 会复制 symbol 属性。</p>
<p>symbol 可以在全局使用，利用 symbol.for(),此方法会查找全局 symbol 表，如果 symbol 不存在，则创建它。
<div class="highlight"><pre><span></span><code><span class="c1">// 从全局注册表中读取</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// 如果该 symbol 不存在，则创建它</span>

<span class="c1">// 再次读取（可能是在代码中的另一个位置）</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">idAgain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">);</span>

<span class="c1">// 相同的 symbol</span>
<span class="nx">alert</span><span class="p">(</span><span class="w"> </span><span class="nx">id</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">idAgain</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// true</span>
</code></pre></div></p>
<p>JS 内部有很多&rdquo;系统&rdquo;层的 symbol，通过它们可以微调对象的各个方面：</p>
<div class="highlight"><pre><span></span><code><span class="nb">Symbol</span><span class="p">.</span><span class="nx">hasInstance</span>
<span class="nb">Symbol</span><span class="p">.</span><span class="nx">isConcatSpreadable</span>
<span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span>
<span class="nb">Symbol</span><span class="p">.</span><span class="nx">toPrimitive</span>
<span class="p">...</span>
</code></pre></div>
<p>Object.keys/values/entries 会忽略 symbol 属性</p>
<h4>类数组</h4>
<p>类数组是有索引和 length 属性的对象。类数组没有数组的一些方法，比如 pop、push。可以通过 Array.from 将其转为数组。</p>
<p>类数组也不能通过 for&hellip;of 遍历。</p>
<p>技术上来说，可迭代对象必须实现 Symbol.iterator 方法。
obj<a href="">Symbol.iterator</a> 的结果被称为 迭代器（iterator）。由它处理进一步的迭代过程。
一个迭代器必须有 next() 方法，它返回一个 {done: Boolean, value: any} 对象，这里 done:true 表明迭代结束，否则 value 就是下一个值。
Symbol.iterator 方法会被 for..of 自动调用，但我们也可以直接调用它。
内建的可迭代对象例如字符串和数组，都实现了 Symbol.iterator。
字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）</p>
<h2>Promise 和 async/await</h2>
<p>在使用 promise 时候，为了防止代码抛出异常影响正常流程，需要增加 catch。
<div class="highlight"><pre><span></span><code><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">noSuchFunction</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这里出现 error（没有这个函数）</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{});</span>
<span class="c1">// VM5149:2 Uncaught (in promise) ReferenceError: noSuchFunction is not defined</span>

<span class="k">try</span><span class="p">{</span>
<span class="w">  </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">noSuchFunction</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这里出现 error（没有这个函数）</span>
<span class="w">  </span><span class="p">}).</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{});</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 无法捕获 promise 中的错误</span>
<span class="p">}</span>
</code></pre></div>
可以对上面的代码增加 catch 方法：
<div class="highlight"><pre><span></span><code><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">noSuchFunction</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这里出现 error（没有这个函数）</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{}).</span><span class="k">catch</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{});</span>
</code></pre></div></p>
<p>async/await 可以通过 try&hellip;catch 捕获异常
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;http://no-such-url&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">alert</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span><span class="w"> </span><span class="c1">// TypeError: failed to fetch</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="nx">f</span><span class="p">()</span>
</code></pre></div></p>
<h2>可迭代对象 和 generator</h2>
<p>可迭代对象是数组的泛化，可迭代对象需要对象实现 Symbol.iterator 方法，并返回带有 next 方法的对象。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kr">from</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span>
<span class="w">  </span><span class="nx">to</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span>
<span class="p">};</span>

<span class="c1">// 1. for..of 调用首先会调用这个：</span>
<span class="nx">range</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// ……它返回迭代器对象（iterator object）：</span>
<span class="w">  </span><span class="c1">// 2. 接下来，for..of 仅与下面的迭代器对象一起工作，要求它提供下一个值</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">current</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="kr">from</span><span class="p">,</span>
<span class="w">    </span><span class="nx">last</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">to</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// 3. next() 在 for..of 的每一轮循环迭代中被调用</span>
<span class="w">    </span><span class="nx">next</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// 4. 它将会返回 {done:.., value :...} 格式的对象</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">current</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">last</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">done</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">current</span><span class="o">++</span><span class="w"> </span><span class="p">};</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">done</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="p">};</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">};</span>

<span class="c1">// 现在它可以运行了！</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">num</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">range</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">alert</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1, 然后是 2, 3, 4, 5</span>
<span class="p">}</span>
</code></pre></div>
<h2>递归</h2>
<p>递归是一种强大的抽象，使得问题解决自然而然，而且代码量小。但是由于递归的执行机制，递归所使用的内存空间会比较大。好在递归基本上都可以转化为循环的实现，从而降低内存空间的占用。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 非尾递归</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 尾递归</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 循环</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="nx">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">x</span>
<span class="w">    </span><span class="nx">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span>
<span class="p">}</span>
</code></pre></div>
<p>不同的递归实现，其表现出来的执行时的形状是不一致的。尾递归很容易转换为循环。</p>
<p>递归的汇编实现？</p>
<h2>Proxy 和 Reflect</h2>
<h2>事件循环</h2>
<p>浏览器中 JS 的执行流程和 Node.js 中的执行流程都是基于事件循环的。
正因为事件循环才让 JS 变成了异步事件驱动的变成模型。</p>
<p>JS 事件通过事件队列实现，事件队列分为：宏任务队列和微任务队列</p>
<p>宏任务包括：鼠标事件，脚本加载事件、setTimeout 等，宏任务是更底层的机制。</p>
<p>微任务包括： Promise、async/await，微任务主要来自我们编写的代码。</p>
<p>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。
<div class="highlight"><pre><span></span><code><span class="nx">setTimeout</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;timeout&#39;</span><span class="p">))</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;promise&#39;</span><span class="p">))</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;console&#39;</span><span class="p">)</span>
<span class="c1">// console</span>
<span class="c1">// promise</span>
<span class="c1">// timeout</span>
</code></pre></div></p>
<object type="image/svg+xml" data="https://zh.javascript.info/article/event-loop/eventLoop-full.svg" width="407" height="391" class="image__image" data-use-theme="">
        <img src="https://zh.javascript.info/article/event-loop/eventLoop-full.svg" alt="" width="407" height="391">
      </object>

<div class="highlight"><pre><span></span><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">1</span><span class="p">);</span>
<span class="nx">setTimeout</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">2</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">3</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setTimeout</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">4</span><span class="p">)));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">5</span><span class="p">));</span>
<span class="nx">setTimeout</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">6</span><span class="p">));</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mf">7</span><span class="p">);</span>
<span class="c1">// 1</span>
<span class="c1">// 7</span>
<span class="c1">// 3</span>
<span class="c1">// 5</span>
<span class="c1">// 2</span>
<span class="c1">// 6 </span>
<span class="c1">// 4</span>
</code></pre></div>
<h2>事件冒泡和捕获</h2>
<p>事件冒泡是从里向外，事件捕获是从外向里。通过设置 addEventListener 的参数可以进行控制。</p>
<p>事件委托是基于事件冒泡或事件捕获实现的，通过判断 event.target 是不是待处理的元素来实现</p>
<p><div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;books&quot;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;book&quot;</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;book&quot;</span><span class="p">&gt;</span>2<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;.books&#39;</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">className</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;book&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;selected&#39;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></p>
<p>event.target 获取的是实际触发时间的元素，event.currentTarget 获取的是绑定此事件的元素</p>
<p>事件捕获很少在实际开发中应用，之前主要是因为事件捕获并未被大多数浏览器实现。</p>
<h2>创建自定义事件</h2>
<h2>浏览器中的数据存储</h2>
<h2>HTML文档加载和资源加载</h2>
<p>HTML 页面主要声明周期包括三个 <code>DOMContentLoaded</code>,<code>load</code>,<code>beforeunload</code>,<code>unload</code></p>
<p><code>DOMContentLoaded</code>  浏览器已完全加载 HTML，并构建了 DOM 树，但像 <img> 和样式表之类的外部资源可能尚未加载完成</p>
<p><code>load</code>在页面中所有资源加载完毕后触发，包含图片资源，样式表。</p>
<p>DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。</p>
<p>load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。</p>
<p>beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。</p>
<p>unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。</p>
<h3>script 的 defer 和 async</h3>
<p>script 会阻塞 DOM 的构建，需要 script 执行完成才能继续 DOM 的构建。这会带来两个问题：</p>
<ol>
<li>脚本不能访问它下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。</li>
<li>如果脚本执行时间长，它会阻塞页面，用户可能看不到页面内容，这也是为什么推荐将脚本放在 body 的最后面的原因。</li>
</ol>
<p>浏览器支持给 script 设置 defer 和 async 属性</p>
<p>defer 会延迟加载脚本，让 script 不阻塞 DOM 的构建，等 DOM 构建完成后带有 defer 的脚本才会执行。</p>
<ul>
<li>具有 defer 特性的脚本不会阻塞页面。</li>
<li>具有 defer 特性的脚本总是要等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行。</li>
<li>具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。
<div class="highlight"><pre><span></span><code><span class="o">&lt;</span><span class="nx">script</span><span class="w"> </span><span class="nx">defer</span><span class="w"> </span><span class="nx">src</span><span class="o">=</span><span class="s2">&quot;https://javascript.info/article/script-async-defer/long.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
<span class="o">&lt;</span><span class="nx">script</span><span class="w"> </span><span class="nx">defer</span><span class="w"> </span><span class="nx">src</span><span class="o">=</span><span class="s2">&quot;https://javascript.info/article/script-async-defer/small.js&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
</code></pre></div></li>
<li>如果 <script> 脚本没有 src，则会忽略 defer 特性。</li>
</ul>
<p>async 特性意味着脚本是完全独立的：</p>
<ul>
<li>浏览器不会因 async 脚本而阻塞（与 defer 类似）。</li>
<li>其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本。</li>
<li>DOMContentLoaded 和异步脚本不会彼此等待</li>
<li>异步脚本以“加载优先”的顺序执行。</li>
</ul>
<h2>字符串</h2>
<p>JS 中的字符串和其他语言的字符串不一样，其他语言中的字符串用对象表示。</p>
<p>在 js 中，字符串分为字符串字面量和字符串对象，字符串字面量不能设置属性。字符串对象能设置属性。</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;test string&#39;</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;test name&#39;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">String</span><span class="p">(</span><span class="s1">&#39;test string&#39;</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;test name&#39;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</code></pre></div>
<p>在调用字符串字面量的方式入 substring 等方法时，会创建包装类型的对象，例如：<code>a.substring(2)</code>实际相当于执行如下：
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">String</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
<span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span>
</code></pre></div></p>
<p>Object 构造函数是一个工厂方法，能根据传入的值返回相应的原始值包装类型的实例。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Object</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Object</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="nb">Boolean</span><span class="p">)</span>
</code></pre></div>
<p>通过构造函数创建的数字、字符串、布尔值，都是 object 类型。</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">String</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">str</span><span class="w"> </span><span class="c1">// object</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">toString</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="w"> </span><span class="c1">// &#39;[object String]&#39;</span>
<span class="ow">typeof</span><span class="w"> </span><span class="s1">&#39;test&#39;</span><span class="w"> </span><span class="c1">// string</span>
</code></pre></div>
<p>字符串也是类数组，因为有下标和 length 属性。</p>
<h2>单例内置对象</h2>
<p>单例内置对象包含 Global 和 Math。Global 是 ECMA-262 规定的兜底对象。isNaN、isFinite、parseInt、parseFloat、encodeURI、encodeURIComponent 在 global 对象上。</p>
<p>global 对象上的属性：undefined\NaN\Infinity\Object\Array\Function\Boolean\String\Number\Date\RegExp\Symbol\Error\EvalError\RangeError\ReferenceError\SyntaxError\TypeError\URIError</p>
<p>encodeURI 不会编码 URL 组件的特殊字符,比如 冒号、斜杠、问号、井号</p>
<p>encodeURIComponent 会对所有字符进行编码。</p>
<p>eval 所执行的代码和 eval 调用的代码共享作用域。
<div class="highlight"><pre><span></span><code><span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;let msg = &#39;test&#39;&quot;</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
</code></pre></div></p>
<h2>数组空位</h2>
<p>可以使用一串逗号创建空位。ES6 遍历这种数组，会将值当 undefined。ES6 之前的方法则会忽略这个空位，但具体行为也会因方法而异。
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="mf">2</span><span class="p">]</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span>

<span class="k">for</span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 1</span>
</code></pre></div></p>
<p>ES6 新增方法： fill、copyWithin</p>
<h2>对象池的实现</h2>
<h2>正则表达式</h2>
<p>全局匹配 vs 多行匹配</p>
<p>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
m：多行模式，表示查找到一行文本末尾时会继续查找。</p>
        </article>
        
        <script src="https://giscus.app/client.js"
                data-repo="oasis-cloud/blog-comments"
                data-repo-id="R_kgDOKEliHA"
                data-category="General"
                data-category-id="DIC_kwDOKEliHM4CYb6e"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="preferred_color_scheme"
                data-lang="zh-CN"
                crossorigin="anonymous"
                async>
        </script>
    </body>
</html>
