<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>MCP 协议入门：基础概念</title>
        <link rel="stylesheet" href="../../../assets/fonts.css">
        <link rel="stylesheet" href="../../../assets/graphite.css">
        <link rel="stylesheet" href="../../../assets/pygments.css">
        <script src="../../../assets/image-zoom.js" defer></script>
        
        
    </head>
    <body class="node-articles-artificial-intelligence-mcp-1 node-articles-artificial-intelligence-mcp node-articles-artificial-intelligence node-articles node">
        <header class="masthead">
            <h1><a href="../../../index.html">Oasis's Cloud</a></h1>
            
                <p class="tagline">一个人的首要责任，就是要有雄心。雄心是一种高尚的激情，它可以采取多种合理的形式。<br />—— 《一个数学家的辩白》</p>
            
            
            <nav class="menu">
                <input id="menu-check" type="checkbox"/>
                <label id="menu-label" for="menu-check" class="unselectable">
                    <span class="icon close-icon">✕</span>
                    <span class="icon open-icon">☰</span>
                    <span class="text">Menu</span>
                </label>
                <ul>
<li><a href="../../../index.html">首页</a></li>
</ul>
            </nav>
        </header>
        <article class="main">
            <header class="title">
                <h1>MCP 协议入门：基础概念</h1>
                
                
                    <p class="author">作者：oasis</p>
                
                <hr>
            </header>
            <h2>MCP 概念</h2>
<p>MCP 是一个将人工智能应用连接到外部系统的开源标准。MCP 被比喻为 USB-C，就像 USB-C 为电子设备提供了一种标准的连接方式。</p>
<h2>为什么需要 MCP</h2>
<p>大语言模型虽然强大，但存在一些缺点：</p>
<ol>
<li><strong>知识时效性问题</strong>：大语言模型是基于历史数据训练的，模型训练完成后，其知识就停留在训练时的状态，无法自动获取训练之后的信息。也就是说大语言模型的知识和实时需求之间存在信息差。</li>
</ol>
<p>为了解决大模型对训练后信息的获取问题，行业探索出两类解决方案：模型微调和上下文补充。</p>
<p>模型微调是在预训练好的大模型的基础上，使用新的数据集进行额外训练，从而使模型学习新的知识或适应特定任务。</p>
<p>上下文补充是为大模型提供外部知识库或信息源的技术方案。其目的是让大模型突破知识的时效性限制，能够访问专业领域信息，从而提高回答的准确性、时效性和可靠性。目前主要有以下三种方案：</p>
<ul>
<li><strong>记忆存储</strong>：大模型客户端会将用户与大模型的每轮对话内容记录下来，并设定一定的记忆容量。但设定容量限制会导致大模型的上下文长度超出限制，影响对话的连贯性。</li>
<li><strong>RAG（检索增强生成）</strong>：当用户发出提问时，AI应用通过向量检索、关键词匹配等方式，从外部知识库或数据源检索相关信息，再把检索到的信息作为上下文提供给大模型，让大模型基于补充的信息进行回答。</li>
<li>
<p><strong>函数调用（Function Calling）</strong>：让大模型执行特定任务，允许大模型将自然语言请求转换为具体的函数调用，供 AI 应用调用外部工具，并将结果反馈给用户。</p>
</li>
<li>
<p><strong>智能体开发适配难度大</strong>：例如在 ChatGPT 平台创建了一个 GPTs，想要把 GPTs 部署到其他平台时，发现无法复用 GPTs。而且 GPTs 默认只能在云端处理数据，如果有上传操作，会存在隐私泄漏的风险。</p>
</li>
</ul>
<p>MCP 提供了一个标准化协议，能让大语言模型以一致的方式访问外部信息和工具，同时借助标准化协议，可以让智能体扩展平台更加容易。</p>
<h2>MCP 的灵感</h2>
<p>MCP 的设计受到了 <a href="https://microsoft.github.io/language-server-protocol/">LSP</a> 的启发。 LSP 是语言服务器协议，其目的是标准化编辑器与语言服务器之间的交互。它将代码补全、错误检查、智能跳转等功能从编辑器中解耦，有独立的语言服务器提供。</p>
<p>LSP 基于 JSON-RPC，通过统一的请求和响应格式，实现了编辑器与语言服务器之间的高效通信。</p>
<p>MCP 借鉴了 LSP 的架构设计，在应用层定义了三类角色：主机、客户端、服务器。</p>
<p>MCP 除了借鉴 LSP 的架构设计，还借鉴了 LSP 中的几个优秀的设计理念：
- 资源与应用解耦，通过外部服务器连接数据或服务
- 支持本地运行，服务器可作为本地进程运行，通过标准IO与客户端通信
- 将 JSON-RPC 作为数据的交换标准
- 一次实现，多端复用。主要是反向让大模型应用（主机）提供 MCP 客户端的实现，从而对接 MCP 服务器。这样 MCP 服务器就可以单独开发。</p>
<h2>JSON-RPC</h2>
<p>RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许程序能够像调用本地函数一样调用另一台计算机上的子程序，而无需编写底层网络通信代码。</p>
<p>一个完整的 RPC 框架通常包含客户端存根、网络传输和服务器端存根三个关键部分，其工作流程概括如下：</p>
<ol>
<li>客户端（调用方）：调用一个本地的&rdquo;存根&rdquo;函数(可理解为占位符或代理函数)</li>
<li>客户端存根：它看起来和远程函数一模一样<ul>
<li>序列化（编码或封送）：将函数名、参数等信息打包成一个可以被网络传输的消息格式（JSON、XML等）</li>
<li>通过网络将消息发送给服务器</li>
</ul>
</li>
<li>网络传输：使用某种网络协议（TCP、HTTP）将数据包从客户端传送到服务器</li>
<li>服务器端存根：接收网络请求<ul>
<li>反序列化（解码或解封送）：将接收到的消息包解析出来，还原成函数名和参数</li>
<li>根据函数名，调用服务器上真正的函数实现</li>
</ul>
</li>
<li>服务器执行真正的业务逻辑，获得结果</li>
<li>返回结果：服务器将结果按照同样的路径（序列化 -&gt; 网络传输 -&gt; 反序列化）返回给客户端</li>
<li>客户端存根拿到结果，并将其作为本地调用的返回值。对于客户端程序来说，它感觉就像调用了一个本地函数一样</li>
</ol>
<p>客户端存根 是 RPC 框架在调用方（客户端）的一个代理组件。它的主要目的是隐藏进行远程调用的所有底层复杂细节，让客户端觉得它只是在做一个普通的本地函数调用。</p>
<h2>MCP 架构中的关键角色</h2>
<ol>
<li>MCP Host：MCP 主机负责协调和管理一个或多个 MCP 客户端的智能体,例如：Cursor。</li>
<li>MCP Client：MCP 客户端是一个保持与 MCP 服务器连接的组件，并从 MCP 服务器获取上下文供 MCP 主机使用。</li>
<li><strong>MCP Server</strong>：MCP 服务器是一个向 MCP 客户端提供上下文的程序，例如调用数据库查询、操作浏览器等。</li>
</ol>
<p>MCP 客户端和 MCP 服务器采用一对一的点到点连接方式。以官方示例为例：Visual Studio Code 充当 MCP 主机。当 Visual Studio Code 与 MCP 服务器（如 Sentry MCP 服务器）建立连接时，Visual Studio Code 运行时会实例化一个 MCP 客户端对象，该对象保持与 Sentry MCP 服务器的连接。当 Visual Studio Code 随后连接到另一个 MCP 服务器（如本地文件系统服务器）时，Visual Studio Code 运行时会实例化另一个 MCP 客户端对象以保持此连接，从而维持 MCP 客户端与 MCP 服务器的一对一关系。</p>
<p><img alt="img.png" src="/images/ai/iShot_2025-11-22_10.29.50.png" /></p>
<p>客户端和服务器之间的数据交换采用 JSON-RPC 协议。数据传输支持两种方式：</p>
<ul>
<li><strong>stdio 传输</strong>：适合调用本地服务器，通过标准输入输出进行通信</li>
<li><strong>流式 HTTP 传输</strong>：支持远程服务器通信，并支持标准 HTTP 认证方法，包括令牌、API 密钥和自定义头信息</li>
</ul>
<p>MCP 推荐使用 OAuth 获取认证令牌。</p>
<h2>授权机制</h2>
<p>MCP 遵循 OAuth 2.1 的规范，建立 MCP 客户端和 MCP 服务器之间的信任。</p>
<p>OAuth 的一个使用示例是，最终用户（资源所有者）授权一个财务管理服务（客户端）访问其存储在银行服务（资源服务器）中的敏感交易历史记录，而无需将用户名和密码共享给财务管理服务。相反，他们直接通过其金融机构的服务器（授权服务器）进行身份验证，该服务器会为财务管理服务颁发特定于委托的凭证（访问令牌）。</p>
<p>OAuth 是一个授权协议，而非认证协议，因为 OAuth 并未定义实现用户认证所需的必要组件。如果目标是认证用户，则必须使用认证协议。例如 OpenID Connect（OpenID），它基于 OAuth 提供认证协议所需的必要安全特性和组件。</p>
<h2>参考</h2>
<p><a href="https://modelcontextprotocol.io/">MCP 官方文档</a>
<a href="https://weread.qq.com/web/reader/16b32940813aba373g01724a">《这就是MCP》</a></p>
        </article>
        
        <script src="https://giscus.app/client.js"
                data-repo="oasis-cloud/blog-comments"
                data-repo-id="R_kgDOKEliHA"
                data-category="General"
                data-category-id="DIC_kwDOKEliHM4CYb6e"
                data-mapping="pathname"
                data-strict="0"
                data-reactions-enabled="1"
                data-emit-metadata="0"
                data-input-position="bottom"
                data-theme="preferred_color_scheme"
                data-lang="zh-CN"
                crossorigin="anonymous"
                async>
        </script>
    </body>
</html>
