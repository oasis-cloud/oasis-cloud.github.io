
## "use strict"

"use strict" 可以明确地激活 ES5 新增的特性和一些被修改过的特性。

"use strict" 可以放在脚本最顶部。
放在脚本的最顶部，则整个文件都以现代模式工作。

## 变量

JS 中变量声明可以通过 var、let、const，

var 声明的变量存在变量提升，如下例子
```js
function a() {
    console.log(b) // undefined
    var b = 1
    console.log(b) // 1
}
```
通过 let 声明的变量不存在提升。

```js
function a() {
    console.log(b) // Uncaught ReferenceError: Cannot access 'b' before initialization
    let b = 1
    console.log(b) // 1
}
```

在 if 等语句中通过 var 声明的变量可以在程序中的其他地方使用，例如：
```js
if(true) {
    var a = 10
}
function say() {
    console.log(a) // 10
}
```
通过 let 和 const 声明的变量则存在块级作用域的限制。

```js
if(true) {
    let a = 10
}
function say() {
    console.log(a) // a is not defined
}
```

通过 var 声明变量的话可以重复声明。而 let 和 const 不可以。

const 表示声明一个常量，而且要声明和初始化一起。否则会报错。

const 声明并初始化一个数组或对象，我们可以修改数组的元素或对象属性的值。这里的深层原因是 const 保留的是数组或对象的指针，仅仅是确保指针不变。

如何声明不可修改的对象呢？可以通过 Object.defineProperty()
```js
const a = {}
Object.defineProperty(a, 'property1', {
  value: 42,
  writable: false
});
a.property1 = 1
console.log(a) // {property1: 42}
```

## 类型

首先思考为什么编程语言中提供了类型这种抽象，类型帮助我们解决了什么问题？

- 类型解决了数据存的问题：通过不同的类型，编译器可以开辟不同的内存大小，解决数据如何存的问题。
- 类型解决了数据取的问题：由于内存中的数据本没有意义，而是通过人为的界定数据才有了实际的意义，比如内存中同样的 4 个字节，存放着同样的二进制码，如果这两块内存对应的两个变量类型不一样，那么它们意义就不一样了。

JS 中主要提供了如下类型：

- boolean
- number
- string
- null
- undefined
- symbol
- bigint
- object

在 JS 中 函数和正则都属于 object 类型，数组也属于 object 类型。

### 类型转换
转换算法是：

- 调用 obj[Symbol.toPrimitive](hint) 如果这个方法存在，
- 否则，如果 hint 是 "string"
  - 尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。
- 否则，如果 hint 是 "number" 或者 "default"
  - 尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。



### null 和 undefined 的却别

- null 代表“无”、“空”或“值未知”的特殊值，undefined 表示未被赋值
- typeof null 返回 object，typeof undefined 返回 undefined
- null === null // true
- undefined === undefined // ture
- undefined === null // false


### number 类型注意点

- 0.1 + 0.2 === 0.3 // false
- NaN == NaN // false
- NaN === Nan // false

NaN 表示不是一个数字，比如做显示类型转换的时候可能会得到这个结果。 Number(0/0)

### 数组的检测

- `Array.isArray()`
- `Object.prototype.toString.call([])`，解释原理：

### Object 类型

#### 对象的创建
- 可通过对象字面量创建
- 可通过 new 关键字创建
  - new 关键字的过程如下
    - 一个新的空对象被创建并分配给 this。
    - 函数体执行。通常它会修改 this，为其添加新的属性。
    - 返回 this 的值。
- 可通过 Object.create() 创建，使用 Object.create(null) 创建原型为 null 的对象。相当于使用 `{__proto__: null}`

#### 对象的继承

- 通过 `Object.create()` 实现继承

- 通过 `prototype` 实现继承

- 通过 `mixin` 实现继承

#### `__proto__` 和  `prototype` 的区别

#### `for .. in` 和 `for ... of` 区别

- for..in 会跳过 symbol
- for..in 会遍历出原型链上的属性
- for..of 用与可迭代对象

#### symbol

表示唯一标识，for..in 会跳过 symbol。Object.assign 会复制 symbol 属性。

symbol 可以在全局使用，利用 symbol.for(),此方法会查找全局 symbol 表，如果 symbol 不存在，则创建它。
```js
// 从全局注册表中读取
let id = Symbol.for("id"); // 如果该 symbol 不存在，则创建它

// 再次读取（可能是在代码中的另一个位置）
let idAgain = Symbol.for("id");

// 相同的 symbol
alert( id === idAgain ); // true
```

JS 内部有很多“系统”层的 symbol，通过它们可以微调对象的各个方面：

 ```js
Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
...
```

#### 类数组

## Promise 和 async/await

## 可迭代对象 和 generator

## Proxy 和 Reflect

## 事件循环

## 事件冒泡和捕获

## 创建自定义事件

## 浏览器中的数据存储

## HTML文档加载和资源加载

HTML 页面主要声明周期包括三个 `DOMContentLoaded`,`load`,`beforeunload`,`unload`

`DOMContentLoaded`  浏览器已完全加载 HTML，并构建了 DOM 树，但像 <img> 和样式表之类的外部资源可能尚未加载完成

`load`在页面中所有资源加载完毕后触发，包含图片资源，样式表。

DOMContentLoaded 事件 —— DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口。

load 事件 —— 外部资源已加载完成，样式已被应用，图片大小也已知了。

beforeunload 事件 —— 用户正在离开：我们可以检查用户是否保存了更改，并询问他是否真的要离开。

unload 事件 —— 用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据。

### script 的 defer 和 async

script 会阻塞 DOM 的构建，需要 script 执行完成才能继续 DOM 的构建。这会带来两个问题：

1. 脚本不能访问它下面的 DOM 元素，因此，脚本无法给它们添加处理程序等。
2. 如果脚本执行时间长，它会阻塞页面，用户可能看不到页面内容，这也是为什么推荐将脚本放在 body 的最后面的原因。

浏览器支持给 script 设置 defer 和 async 属性

defer 会延迟加载脚本，让 script 不阻塞 DOM 的构建，等 DOM 构建完成后带有 defer 的脚本才会执行。

- 具有 defer 特性的脚本不会阻塞页面。
- 具有 defer 特性的脚本总是要等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行。
- 具有 defer 特性的脚本保持其相对顺序，就像常规脚本一样。
```js
<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
```
- 如果 <script> 脚本没有 src，则会忽略 defer 特性。

async 特性意味着脚本是完全独立的：

- 浏览器不会因 async 脚本而阻塞（与 defer 类似）。
- 其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本。
- DOMContentLoaded 和异步脚本不会彼此等待
- 异步脚本以“加载优先”的顺序执行。

### 重排和重绘




## web components

## 正则表达式

