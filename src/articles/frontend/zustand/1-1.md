---
title: "zustand 源码分析"
author: oasis
---

## zustand 简介

Zustand 是一个轻量级、快速且可扩展的状态管理解决方案，基于简化的 Flux 原则设计。它的 API 基于 React Hooks，没有过多的样板代码，也不强制特定的使用模式。

### 核心特点

- **轻量级**：体积小，打包后仅几 KB
- **简单易用**：基于 Hooks 的舒适 API，无需 Provider 包裹
- **性能优秀**：解决了 React 并发模式下的常见问题，如僵尸子组件问题、上下文丢失等
- **类型安全**：完整的 TypeScript 支持
- **灵活扩展**：支持中间件机制，可以轻松扩展功能

## zustand 基础用法

### 创建 Store

```typescript
import { create } from 'zustand'

const useBearStore = create((set) => ({
  bears: 0,
  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 }),
}))
```

### 在组件中使用

```typescript
function BearCounter() {
  const bears = useBearStore((state) => state.bears)
  return <h1>{bears} around here ...</h1>
}

function Controls() {
  const increasePopulation = useBearStore((state) => state.increasePopulation)
  return <button onClick={increasePopulation}>one up</button>
}
```

### 核心优势

相比 Redux：
- 更简单，不强制特定模式
- 以 Hooks 为主要消费方式
- 不需要用 Context Provider 包裹应用

相比 Context API：
- 更少的样板代码
- 只在变化时渲染组件
- 集中式、基于 action 的状态管理

## zustand 的 create 方法执行过程

### 1. create 函数入口

从 `src/react.ts` 可以看到 `create` 函数的定义：

```54:65:src/react.ts
const createImpl = <T>(createState: StateCreator<T, [], []>) => {
  const api = createStore(createState)

  const useBoundStore: any = (selector?: any) => useStore(api, selector)

  Object.assign(useBoundStore, api)

  return useBoundStore
}

export const create = (<T>(createState: StateCreator<T, [], []> | undefined) =>
  createState ? createImpl(createState) : createImpl) as Create
```

`create` 函数支持两种调用方式：
- 直接传入 `createState`：`create(createState)`
- 柯里化调用：`create<State>()(createState)`

### 2. createStore 核心实现

`create` 内部调用 `createStore`，这是状态管理的核心实现，位于 `src/vanilla.ts`：

```58:95:src/vanilla.ts
const createStoreImpl: CreateStoreImpl = (createState) => {
  type TState = ReturnType<typeof createState>
  type Listener = (state: TState, prevState: TState) => void
  let state: TState
  const listeners: Set<Listener> = new Set()

  const setState: StoreApi<TState>['setState'] = (partial, replace) => {
    // TODO: Remove type assertion once https://github.com/microsoft/TypeScript/issues/37663 is resolved
    // https://github.com/microsoft/TypeScript/issues/37663#issuecomment-759728342
    const nextState =
      typeof partial === 'function'
        ? (partial as (state: TState) => TState)(state)
        : partial
    if (!Object.is(nextState, state)) {
      const previousState = state
      state =
        (replace ?? (typeof nextState !== 'object' || nextState === null))
          ? (nextState as TState)
          : Object.assign({}, state, nextState)
      listeners.forEach((listener) => listener(state, previousState))
    }
  }

  const getState: StoreApi<TState>['getState'] = () => state

  const getInitialState: StoreApi<TState>['getInitialState'] = () =>
    initialState

  const subscribe: StoreApi<TState>['subscribe'] = (listener) => {
    listeners.add(listener)
    // Unsubscribe
    return () => listeners.delete(listener)
  }

  const api = { setState, getState, getInitialState, subscribe }
  const initialState = (state = createState(setState, getState, api))
  return api as any
}
```

### 3. 执行流程详解

**步骤 1：初始化状态**
```typescript
const initialState = (state = createState(setState, getState, api))
```
- 调用 `createState` 函数，传入 `setState`、`getState` 和 `api`
- `createState` 返回初始状态对象
- 将返回的状态赋值给 `state` 变量

**步骤 2：实现 setState**
- 支持函数式更新：`set((state) => ({ count: state.count + 1 }))`
- 支持对象更新：`set({ count: 1 })`
- 使用 `Object.is` 进行浅比较，避免不必要的更新
- 默认合并策略：使用 `Object.assign` 进行浅合并
- 可通过 `replace` 参数完全替换状态

**步骤 3：实现订阅机制**
- 使用 `Set<Listener>` 存储所有监听器
- `subscribe` 返回取消订阅的函数
- 状态更新时，遍历所有监听器并调用

**步骤 4：创建 React Hook**
```typescript
const useBoundStore: any = (selector?: any) => useStore(api, selector)
Object.assign(useBoundStore, api)
```
- 创建一个函数，可以作为 Hook 使用
- 将 `api` 的方法（`setState`、`getState`、`subscribe` 等）挂载到函数上
- 这样既可以用作 Hook，也可以直接调用方法

### 4. useStore Hook 实现

```27:38:src/react.ts
export function useStore<TState, StateSlice>(
  api: ReadonlyStoreApi<TState>,
  selector: (state: TState) => StateSlice = identity as any,
) {
  const slice = React.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState()),
  )
  React.useDebugValue(slice)
  return slice
}
```

`useStore` 使用 React 18 的 `useSyncExternalStore` Hook：
- **第一个参数**：`api.subscribe` - 订阅函数
- **第二个参数**：`() => selector(api.getState())` - 获取当前状态的函数
- **第三个参数**：`() => selector(api.getInitialState())` - 获取初始状态的函数（用于 SSR）

这确保了在 React 并发模式下也能正确工作，避免了僵尸子组件等问题。

## zustand 的设计理念

### 1. 极简主义

Zustand 追求极简的 API 设计，核心代码非常精简：

- **单一 Store**：推荐使用单一全局 Store，但支持拆分为多个 slice
- **无 Provider**：不需要用 Context Provider 包裹应用
- **直接更新**：可以直接调用 `set` 更新状态，无需 action 和 reducer

### 2. 不可变状态管理

虽然 Zustand 不强制使用不可变更新库，但它遵循不可变原则：

```typescript
// setState 的合并逻辑
state = (replace ?? (typeof nextState !== 'object' || nextState === null))
  ? (nextState as TState)
  : Object.assign({}, state, nextState)
```

- 默认浅合并，避免深拷贝带来的性能问题
- 支持 `replace` 标志完全替换状态
- 使用 `Object.is` 进行相等性检查，避免不必要的更新

### 3. 订阅者模式

Zustand 使用经典的发布-订阅模式：

```typescript
const listeners: Set<Listener> = new Set()

const subscribe: StoreApi<TState>['subscribe'] = (listener) => {
  listeners.add(listener)
  return () => listeners.delete(listener)
}
```

- 使用 `Set` 存储监听器，自动去重
- 返回取消订阅函数，方便清理
- 状态更新时同步通知所有监听器

### 4. 类型安全

Zustand 充分利用 TypeScript 的类型系统：

```typescript
export type StateCreator<
  T,
  Mis extends [StoreMutatorIdentifier, unknown][] = [],
  Mos extends [StoreMutatorIdentifier, unknown][] = [],
  U = T,
> = ((
  setState: Get<Mutate<StoreApi<T>, Mis>, 'setState', never>,
  getState: Get<Mutate<StoreApi<T>, Mis>, 'getState', never>,
  store: Mutate<StoreApi<T>, Mis>,
) => U) & { $$storeMutators?: Mos }
```

- 支持中间件的类型推断
- 通过泛型确保类型安全
- 支持中间件链的类型组合

### 5. 中间件机制

Zustand 通过中间件机制实现功能扩展：

```typescript
export type Mutate<S, Ms> = number extends Ms['length' & keyof Ms]
  ? S
  : Ms extends []
    ? S
    : Ms extends [[infer Mi, infer Ma], ...infer Mrs]
      ? Mutate<StoreMutators<S, Ma>[Mi & StoreMutatorIdentifier], Mrs>
      : never
```

中间件可以：
- 修改 `setState` 的行为（如 `immer` 中间件）
- 添加新的功能（如 `persist` 中间件）
- 组合多个中间件（如 `devtools` + `persist`）

## zustand 的多个 store 合并逻辑

### 1. Slices Pattern（切片模式）

Zustand 推荐使用 Slices Pattern 来组织大型应用的状态：

```typescript
// 第一个 slice
export const createFishSlice = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
})

// 第二个 slice
export const createBearSlice = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
})

// 合并多个 slice
export const useBoundStore = create((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
}))
```

**工作原理**：
- 每个 slice 都是一个函数，接收 `set`、`get`、`store` 参数
- 使用展开运算符合并多个 slice 的返回值
- 后定义的 slice 会覆盖先定义的同名属性

### 2. combine 中间件

`combine` 中间件提供了另一种合并方式，特别适合需要初始状态的场景：

```15:18:src/middleware/combine.ts
export const combine: Combine =
  (initialState, create) =>
  (...a) =>
    Object.assign({}, initialState, (create as any)(...a))
```

**使用示例**：

```typescript
import { createStore } from 'zustand/vanilla'
import { combine } from 'zustand/middleware/combine'

const positionStore = createStore(
  combine({ position: { x: 0, y: 0 } }, (set) => ({
    setPosition: (position) => set({ position }),
  })),
)
```

**实现原理**：
- `combine` 接收初始状态和状态创建函数
- 返回一个新的状态创建函数
- 使用 `Object.assign` 将初始状态和创建函数返回的状态合并
- 自动推断类型，无需显式类型定义

### 3. 合并策略对比

| 方式 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| Slices Pattern | 大型应用，需要模块化 | 灵活，易于组织 | 需要手动管理类型 |
| combine 中间件 | 需要初始状态 | 类型自动推断 | 功能相对简单 |

### 4. 实际应用示例

```typescript
// 用户 slice
const createUserSlice = (set, get) => ({
  user: null,
  setUser: (user) => set({ user }),
  logout: () => set({ user: null }),
})

// 购物车 slice
const createCartSlice = (set, get) => ({
  items: [],
  addItem: (item) => set((state) => ({ 
    items: [...state.items, item] 
  })),
  removeItem: (id) => set((state) => ({
    items: state.items.filter(item => item.id !== id)
  })),
  getTotal: () => {
    const { items } = get()
    return items.reduce((sum, item) => sum + item.price, 0)
  },
})

// 合并所有 slice
const useStore = create((...a) => ({
  ...createUserSlice(...a),
  ...createCartSlice(...a),
}))

// 使用
function App() {
  const user = useStore((state) => state.user)
  const addItem = useStore((state) => state.addItem)
  const getTotal = useStore((state) => state.getTotal)
  
  return (
    <div>
      {user && <p>Welcome, {user.name}</p>}
      <button onClick={() => addItem({ id: 1, price: 10 })}>
        Add Item
      </button>
      <p>Total: {getTotal()}</p>
    </div>
  )
}
```

### 5. 跨 Slice 通信

Slice 之间可以通过 `get` 函数访问其他 slice 的状态：

```typescript
const createBearFishSlice = (set, get) => ({
  addBearAndFish: () => {
    // 调用其他 slice 的方法
    get().addBear()
    get().addFish()
  },
})
```

这种方式保持了 slice 之间的解耦，同时允许必要的协作。

## 总结

### 核心设计原则

1. **极简 API**：最少的样板代码，最大的灵活性
2. **性能优先**：使用 `Object.is` 进行浅比较，避免不必要的更新
3. **类型安全**：充分利用 TypeScript 的类型系统
4. **可扩展性**：通过中间件机制轻松扩展功能
5. **React 友好**：完美支持 React 18 的并发特性

### 技术亮点

1. **useSyncExternalStore**：使用 React 18 的新 Hook，解决了并发模式下的问题
2. **订阅者模式**：高效的发布-订阅实现，支持精确的更新控制
3. **浅合并策略**：默认浅合并，平衡了性能和易用性
4. **中间件系统**：类型安全的中间件组合机制
5. **Slices Pattern**：模块化的状态组织方式

### 适用场景

- ✅ 中小型应用的全局状态管理
- ✅ 需要简单易用的状态管理方案
- ✅ 希望避免 Redux 的复杂性
- ✅ 需要类型安全的 TypeScript 项目
- ✅ 需要高性能的状态更新

### 不适合的场景

- ❌ 需要时间旅行调试的复杂应用（虽然可以通过 devtools 中间件支持）
- ❌ 需要严格单向数据流的场景（Zustand 更灵活）
- ❌ 需要服务端状态管理的场景（建议配合 React Query 等）

Zustand 通过极简的设计和精心的实现，在状态管理的复杂性和易用性之间找到了完美的平衡点。它的源码虽然简洁，但解决了很多 React 状态管理的痛点，是一个值得学习和使用的优秀库。
