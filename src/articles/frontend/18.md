---
title: "Taro——目标，找到 Taro 如何处理运行时"
---

dir: Desktop/read_taro

https://mermaid.live/

小程序的 app.js 文件内容如下：
```
App({
    onLaunch() {}
})
```


Pages 的文件内容如下：

```
Page({
    data: {},
    onLoad() {},
    onShow() {},
    onReady() {},
})
```

小程序运行需要上面的这种结构和 API。所以 Taro 工程在编译后应该也具备 App，Page 这些内容。

所以这里的关键要看 Taro 如何构建出 App、Page 等内容。这是从工程编译上看。

在看运行时。

小程序的模板如下：

js
```
Page({
  data: {
    demo: {
      motto: 'Hello World',
      oasis: '!!!'
    }
  },
})
```

```
<template name="odd">
  <view> {{ demo.motto }} </view>
</template>
<template name="even">
  <view> {{ demo.oasis }} </view>
</template>

<block wx:for="{{[1, 2, 3, 4, 5]}}">
  <template is="{{item % 2 == 0 ? 'even' : 'odd'}}" data="{{ demo }}"/>
</block>
```

## Taro 编译后的运行情况

源项目中的 pages/index.jsx 中的元素嵌套关系

![img_1.png](18-imgs/img_1.png)

先看编译后的 root 数据：
![img.png](18-imgs/img.png)

```js
const root = {
    cn: [
        {
            cl: 'index',
            cn: [
                {
                    cn: [
                        {
                            nn: '8',
                            sid: '_AG',
                            v: 'Hello world!'
                        }
                    ],
                    nn: '4',
                    sid: '_AH'
                }
            ],
            nn: '2',
            sid: '_AI'
        }
    ]
}
```

这里可以看做虚拟节点树，实际最终要把这棵树的渲染映射到小程序 xml 模板上。


用最简化的例子，来看， pages 下的 index 页面中的 xml 文件加载 base.xml 中的模板，采用编译后的数据 root，进行数据的传递，在通过 xs 计算映射的模板后，最终映射到 tmpl_0_8 

```
<template name="tmpl_0_8">
  <block>{{i.v}}</block>
</template>
```

##  接下来找一个渲染触发的入口

实际编译后小程序项目中  pages/index.js 文件内容：

```
import { createPageConfig } from '@tarojs/runtime'
import component from "!!../../../node_modules/.pnpm/@tarojs+taro-loader@4.0.0_webpack@5.91.0_@swc+core@1.3.96_/node_modules/@tarojs/taro-loader/lib/entry-cache.js?name=pages/index/index!./index.jsx"
var config = {"navigationBarTitleText":"首页"};


var inst = Page(createPageConfig(component, 'pages/index/index', {root:{cn:[]}}, config || {}))


export default component
```

components/index.js 实际上是 
![img_2.png](18-imgs/img_2.png)

createPageConfig，来自 @tarojs/runtime

这里创建 page json 的静态结构, 在这个步骤中，只初始化了 root 数据，实际的数据处理在哪？这个问题比较重要。

useState 来自 webpack/container/remote/react

这里在前面创建的数据基础上，由 React 来驱动数据更新。

#### 这里既要考虑 小程序渲染模板树的收集，又要考虑 react 如何驱动渲染。

##### 小程序渲染树 root 的收集
这里主要看 react 渲染机制如何在小程序渲染机制的上层建立

##### react 如何驱动数据更新， useState 
这里只要看与 root 数据的关系，react jsx 与 小程序 template 的关系


Taro 小程序采用了 react 创建组件，但是渲染采用了基于 react-reconciler 创建的自定义渲染器 `const TaroReconciler = Reconciler(hostConfig)`

`TaroReconciler` 在封装 render 方法时候，会在 taro-framework-react 的 connect.ts 中调用

createReactApp setReconciler 层的目的是实现解耦，让 react 层插件化。

renderReactRoot


这里需要把 react 


createReactApp

--- 
createPageConfig
connectReactPage

createTaroHook -> @tarojs/plugin-framework-react 框架插件

class Entry extends R.Component


"webpack/container/remote/@tarojs/plugin-platform-weapp/dist/runtime");

webpack/container/remote/@tarojs/plugin-framework-react/dist/runtime

taro-platform-weapp 会重新设计 react-reconciler
```js

import { mergeInternalComponents, mergeReconciler } from '@tarojs/shared'

import { components, hostConfig } from './runtime-utils'

mergeReconciler(hostConfig)
mergeInternalComponents(components)
```

taro-framework-react 中会把 react相关的内容进行 alias 映射
```
alias.set('react-reconciler$', 'react-reconciler/cjs/react-reconciler.production.min.js')
alias.set(/^(?!.*mobx-react$).*react$/, newFilePath)
alias.set('react/jsx-runtime$', 'react/cjs/react-jsx-runtime.production.min.js')
```

扩展阅读：
Taro3可以大致理解为解释型架构，这个工作就主要是在运行时"对代码进行解释"，怎么理解呢？升级为Taro后你可以发现package.json文件里面多了个（当然不止这一个）@taro/runtime的依赖，打开包所在目录：


惊奇的发现了我们在web中才会有的bom跟dom相关的关键字，原来Taro3自己实现了一套类似浏览器的BOM/DOM那一套API，通过webpack的plugin注入到小程序的逻辑层，打包编译后，你最终的代码都是基于BOM/DOM这几个API来实现你的具体功能，比如：不管什么平台，都有自己一套元素dom的规则，都有各自平台的类似bom的全局api规则，Taro3做的就是整合这些厂家的规则封装为类似BOM/DOM的思想去用，也就是说，我不管你开发时用的什么框架，我只要保证你运行时能帮你适配到各个平台即可。

这样做的最直观的好处就是前面说到的，不再受限制与框架本身了，理论上来说，Taro不仅可以支持Vue和React，也能用jquery、Angular等等的库进行跨端开发。站在React的使用者角度：通过taro2和taro3两个项目开发经验来说还有一点最直观的感受，taro3中写JSX更加舒服了！其实就更加友好的支持JSX这一点，应该是顺理成章的，因为taro的架构其实就是无限接近于React的开发体验，适配的工作是通过运行时的BOM/DOM去完成的，而不是像之前版本一样，通过穷举 的方式对 JSX 的写法进行适配。

有个关键点：既然Taro3自己实现了BOM/DOM这一套api，而react的中的渲染器，如react-dom中调用的是浏览器的BOM/DOM的api，那taro肯定会有自己一套渲染器来链接react的协调器（reconciler，diff算法所在阶段）和taro-runtime 的 BOM/DOM api。源码路径：@tarojs/react,description里面的描述如下："like react-dom, but for mini apps."


Root 数据的初始化在 createReactApp 中完成
数据更新由 TaroRootElement 负责管理
实际渲染由 ReactDOM 的 Root 类处理
最终通过小程序的 setData 实现真实 DOM 更新



-----

### createReactApp 方法是 Taro 框架的一个核心方法，用于创建 React 应用并将其适配到小程序环境。


主要功能和实现细节：
初始化设置：
接收主要参数：App 组件、React 实例、ReactDOM 实例和配置对象
设置 React 相关的全局引用
创建应用实例的引用
AppWrapper 核心组件：
继承自 React.Component
管理页面的生命周期
维护页面数组和元素数组
提供页面挂载和卸载的方法
页面管理：
mount 方法：负责新页面的挂载
unmount 方法：处理页面的卸载
使用 connectReactPage 连接 React 组件与小程序页面
渲染机制：
使用 React 18 的新 API 或降级使用旧版本的渲染方式
处理页面栈的管理和渲染
支持异步的页面加载和卸载
生命周期适配：
将 React 的生命周期与小程序的生命周期进行对接
处理页面切换和状态管理
这个实现的主要目的是：
让 React 组件能够在小程序环境中正常运行
处理好小程序的页面栈管理
确保 React 组件的生命周期能够正确响应小程序的事件
提供统一的页面管理机制
通过这种方式，开发者可以使用熟悉的 React 组件开发方式来开发小程序，而 Taro 框架则负责处理底层的适配工作。

TaroRootElement 中的performUpdated 会收集 data 数据，并调用小程序的 setData 更新数据。

### TaroRootElement 是如何收集节点树上的数据的？
1. 在 TaroNode 类中定义了基础的节点操作
```js
        TaroNode = class _TaroNode extends TaroEventTarget {
            updateChildNodes(isClean) {
                const cleanChildNodes = ()=>[];
                const rerenderChildNodes = ()=>{
                    const childNodes = this.childNodes.filter((node)=>!isComment(node));
                    return childNodes.map(hydrate);
                };
                this.enqueueUpdate({
                    path: `${this._path}.${CHILDNODES}`,
                    value: isClean ? cleanChildNodes : rerenderChildNodes
                });
            }
```
这里定义了 updateChildNodes 方法，它负责收集和更新子节点数据。当子节点发生变化时，会调用 hydrate 方法处理每个子节点。
2. hydate 方法
```js
function hydrate(node) {
    var _a2;
    componentsAlias2 || (componentsAlias2 = getComponentsAlias2());
    SPECIAL_NODES || (SPECIAL_NODES = _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.hooks.call("getSpecialNodes"));
    const nodeName = node.nodeName;
    let compileModeName = null;
    if (isText(node)) {
        return {
            sid: node.sid,
            ["v"]: node.nodeValue,
            ["nn"]: ((_a2 = componentsAlias2[nodeName]) === null || _a2 === void 0 ? void 0 : _a2._num) || "8"
        };
    }
    const data = {
        ["nn"]: nodeName,
        sid: node.sid
    };
    if (node.uid !== node.sid) {
        data.uid = node.uid;
    }
    if (!node.isAnyEventBinded() && SPECIAL_NODES.indexOf(nodeName) > -1) {
        data["nn"] = `static-${nodeName}`;
        if (nodeName === VIEW && !isHasExtractProp(node)) {
            data["nn"] = PURE_VIEW;
        }
    }
    const { props } = node;
```
这个方法负责将节点转换为小程序可以理解的数据格式，包括：
- 节点 ID（sid）
- 节点名称（nn）
- 节点值（v）
- 特殊节点的处理
3. 节点的插入和删除操作
```js
       */ insertBefore(newChild, refChild, isReplace) {
                if (newChild.nodeName === DOCUMENT_FRAGMENT) {

                ...

                if (this._root) {
                    if (!refChild) {
                        const isOnlyChild = childNodesLength === 1;
                        if (isOnlyChild) {
                            this.updateChildNodes();
                        } else {
                            this.enqueueUpdate({
                                path: newChild._path,
                                value: this.hydrate(newChild)
                            });
                        }
                    } else if (isReplace) {
                        this.enqueueUpdate({
                            path: newChild._path,
                            value: this.hydrate(newChild)
                        });
                    } else {
                        const mark = childNodesLength * 2 / 3;
                        if (mark > index) {
                            this.updateChildNodes();
                        } else {
                            this.updateSingleChild(index);
                        }
                    }
                }
                MutationObserver2.record({
                    type: "childList",
                    target: this,
                    addedNodes: [
                        newChild
                    ],
                    removedNodes: isReplace ? [
                        refChild
                    ] : [],
                    nextSibling: isReplace ? refChild.nextSibling : refChild || null,
                    /** insertBefore & appendChild */ previousSibling: newChild.previousSibling
                });
                return newChild;
            }
```
在 insertBefore 方法中，会根据不同情况选择更新策略：
- 如果是唯一子节点，更新整个子节点树
- 如果有参考节点，更新单个节点
- 根据节点位置决定是更新整个树还是单个节点
4. 数据更新的入队
```js
            enqueueUpdate(payload) {
    var _a2;
    (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2.enqueueUpdate(payload);
}
```
所有节点的更新都会通过 enqueueUpdate 方法进入更新队列
5. 最终在 performUpdate 中处理更新
```js
            performUpdate(initRender = false, prerender) {
                this.pendingUpdate = true;
                const ctx = _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.hooks.call("proxyToRaw", this.ctx);
                setTimeout(()=>{
                    const setDataMark = `${SET_DATA} \u5F00\u59CB\u65F6\u95F4\u6233 ${Date.now()}`;
                    perf.start(setDataMark);
                    const data = /* @__PURE__ */ Object.create(null);
                    const resetPaths = new Set(initRender ? [
                        "root.cn.[0]",
                        "root.cn[0]"
                    ] : []);
                    while(this.updatePayloads.length > 0){
                        const { path, value } = this.updatePayloads.shift();
                        if (path.endsWith("cn")) {
                            resetPaths.add(path);
                        }
                        data[path] = value;
                    }
                    console.log('performUpdate data:', data);
                    for(const path in data){
                        resetPaths.forEach((p)=>{
                            if (path.includes(p) && path !== p) {
                                delete data[path];
                            }
                        });
                        const value = data[path];
                        if ((0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {
                            data[path] = value();
                        }
                    }
                    if ((0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(prerender)) return prerender(data);
                    this.pendingUpdate = false;
                    let normalUpdate = {};
                    const customWrapperMap = /* @__PURE__ */ new Map();
                    if (initRender) {
                        normalUpdate = data;
                    } else {
                        for(const p in data){
                            const dataPathArr = p.split(".");
                            const found = findCustomWrapper(this, dataPathArr);
                            if (found) {
                                const { customWrapper, splitedPath } = found;
                                customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, customWrapperMap.get(customWrapper) || {}), {
                                    [`i.${splitedPath}`]: data[p]
                                }));
                            } else {
                                normalUpdate[p] = data[p];
                            }
                        }
                    }
                    const customWrapperCount = customWrapperMap.size;
                    const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;
                    const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);
                    let executeTime = 0;
                    const cb = ()=>{
                        if (++executeTime === updateArrLen) {
                            perf.stop(setDataMark);
                            this.flushUpdateCallback();
                            initRender && perf.stop(PAGE_INIT);
                        }
                    };
                    if (customWrapperCount) {
                        customWrapperMap.forEach((data2, ctx2)=>{
                            if (options.debug) {
                                console.log("custom wrapper setData: ", data2);
                            }
                            ctx2.setData(data2, cb);
                        });
                    }
                    if (isNeedNormalUpdate) {
                        if (options.debug) {
                            console.log("page setData:", normalUpdate);
                        }
                        ctx.setData(normalUpdate, cb);
                    }
                }, 0);
```
这个方法会：
- 收集所有待更新的数据
- 处理更新路径
- 区分普通更新和自定义组件更新
- 最终通过 setData 更新到视图层
整个过程形成了一个完整的数据收集链路：
- 节点变化触发更新
- 更新进入队列 
- hydrate 处理节点数据
- performUpdate 统一处理更新
- setData 更新到视图层
这样的设计确保了 React 组件树的变化能够被正确地收集和同步到小程序的数据层。


### createReactApp 和 Page 中的数据是如何通信的
从代码中可以看出，createReactApp 和 Page 的数据通信主要通过以下几个关键步骤：
1. 在 createReactApp 中创建 AppWrapper 组件，它负责管理所有页面：
```js
    class AppWrapper extends react.Component {
        mount(pageComponent, id, cb) {
            const pageWrapper = connectReactPage(react, id)(pageComponent);
            const key = id + pageKeyId();
            const page = ()=>h$1(pageWrapper, {
                    key,
                    tid: id
                });
            this.pages.push(page);
            this.forceUpdate((...args)=>{
                _chunk_R2V3WQ7B_js__WEBPACK_IMPORTED_MODULE_0__.perf.stop(_chunk_R2V3WQ7B_js__WEBPACK_IMPORTED_MODULE_0__.PAGE_INIT);
                return cb(...args);
            });
        }
        unmount(id, cb) {
            const elements = this.elements;
            const idx = elements.findIndex((item)=>item.props.tid === id);
            elements.splice(idx, 1);
            this.forceUpdate(cb);
        }
        render() {
            const { pages, elements } = this;
            while(pages.length > 0){
                const page = pages.pop();
                elements.push(page());
            }
```

2. 当页面需要挂载时，通过 connectReactPage 创建页面包装器：
```js
function connectReactPage(R, id) {
    return (Page)=>{
        const isReactComponent = isClassComponent(R, Page);
        const inject = (node)=>node && (0,_chunk_R2V3WQ7B_js__WEBPACK_IMPORTED_MODULE_0__.injectPageInstance)(node, id);
        const refs = isReactComponent ? {
            ref: inject
        } : {
            forwardedRef: inject,
            // 兼容 react-redux 7.20.1+
            reactReduxForwardedRef: inject
        };
        if (reactMeta.PageContext === _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
            reactMeta.PageContext = R.createContext("");
        }
        return class PageWrapper extends R.Component {
            static getDerivedStateFromError(error) {
                var _a, _b;
                (_b = (_a = _chunk_R2V3WQ7B_js__WEBPACK_IMPORTED_MODULE_0__.Current.app) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error.message + error.stack);
                return {
                    hasError: true
                };
                };
            // React 16 uncaught error 会导致整个应用 crash，
            // 目前把错误缩小到页面
            componentDidCatch(error, info) {
                if (true) {
                    console.warn(error);
                    console.error(info.componentStack);
                }
                }
            render() {
                const children = this.state.hasError ? [] : h$1(reactMeta.PageContext.Provider, {
                    value: id
                }, h$1(Page, Object.assign(Object.assign({}, this.props), refs)));
                if (false) {} else {
                    return h$1("root", {
                        id
                    }, children);
                }
                    }, children);
            constructor(){
                super(...arguments);
                this.state = {
                    hasError: false
                };
            }
                };
    };
```

3. 页面配置通过 createPageConfig 创建，在这里处理页面的生命周期和数据更新：
```js
function createPageConfig(component, pageName, data, pageConfig) {
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.hooks.call("getMiniLifecycleImpl").page;
    let pageElement = null;
    let unmounting = false;
    let prepareMountList = [];
    function setCurrentRouter(page) {
        const router =  false ? 0 : page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!(0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    let loadResolver;
    let hasLoaded;
    const config = {
        [ONLOAD] (options2 = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            perf.start(PAGE_INIT);
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options2, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (false) {}
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            if (true) {
                window2.trigger(CONTEXT_ACTIONS.INIT, $taroPath);
            }
            const mount = ()=>{
                Current.app.mount(component, $taroPath, ()=>{
                    pageElement = env.document.getElementById($taroPath);
                    (0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.ensure)(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                    safeExecute($taroPath, ON_LOAD, this.$taroParams);
                    loadResolver();
                    if (true) {
                        pageElement.ctx = this;
                        pageElement.performUpdate(true, cb);
                    } else {}
                });
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        }
```
主要通信流程是：
1. 数据流向：
- AppWrapper 维护页面栈
- 通过 mount/unmount 方法管理页面的加载和卸载
- 页面实例通过 performUpdate 方法更新数据
- 最终通过小程序的 setData 实现数据同步
2. 更新机制：
- 页面更新时会调用 TaroRootElement 的 performUpdate：
```js
            performUpdate(initRender = false, prerender) {
                this.pendingUpdate = true;
                const ctx = _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.hooks.call("proxyToRaw", this.ctx);
                setTimeout(()=>{
                    const setDataMark = `${SET_DATA} \u5F00\u59CB\u65F6\u95F4\u6233 ${Date.now()}`;
                    perf.start(setDataMark);
                    const data = /* @__PURE__ */ Object.create(null);
                    const resetPaths = new Set(initRender ? [
                        "root.cn.[0]",
                        "root.cn[0]"
                    ] : []);
                    while(this.updatePayloads.length > 0){
                        const { path, value } = this.updatePayloads.shift();
                        if (path.endsWith("cn")) {
                            resetPaths.add(path);
                        }
                        data[path] = value;
                    }
                    console.log('performUpdate data:', data);
                    for(const path in data){
                        resetPaths.forEach((p)=>{
                            if (path.includes(p) && path !== p) {
                                delete data[path];
                            }
                        });
                        const value = data[path];
                        if ((0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) {
                            data[path] = value();
                        }
                    }
                    if ((0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isFunction)(prerender)) return prerender(data);
                    this.pendingUpdate = false;
                    let normalUpdate = {};
                    const customWrapperMap = /* @__PURE__ */ new Map();
                    if (initRender) {
                        normalUpdate = data;
                    } else {
                        for(const p in data){
                            const dataPathArr = p.split(".");
                            const found = findCustomWrapper(this, dataPathArr);
                            if (found) {
                                const { customWrapper, splitedPath } = found;
                                customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, customWrapperMap.get(customWrapper) || {}), {
                                    [`i.${splitedPath}`]: data[p]
                                }));
                            } else {
                                normalUpdate[p] = data[p];
                            }
                        }
                    }
                    const customWrapperCount = customWrapperMap.size;
                    const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;
                    const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);
                    let executeTime = 0;
                    const cb = ()=>{
                        if (++executeTime === updateArrLen) {
                            perf.stop(setDataMark);
                            this.flushUpdateCallback();
                            initRender && perf.stop(PAGE_INIT);
                        }
                    };
                    if (customWrapperCount) {
                        customWrapperMap.forEach((data2, ctx2)=>{
                            if (options.debug) {
                                console.log("custom wrapper setData: ", data2);
                            }
                            ctx2.setData(data2, cb);
                        });
                    }
                    if (isNeedNormalUpdate) {
                        if (options.debug) {
                            console.log("page setData:", normalUpdate);
                        }
                        ctx.setData(normalUpdate, cb);
                    }
                }, 0);
```
3. 事件处理
- React 事件通过 unstable_batchedUpdates 处理批量更新
```js
var unstable_batchedUpdates = (fn, a)=>{
    if (isInsideEventHandler) {
        return fn(a);
    }
    isInsideEventHandler = true;
    try {
        return TaroReconciler.batchedUpdates(fn, a);
    } finally{
        isInsideEventHandler = false;
        finishEventHandler();
    }
};
```
整个通信过程形成了一个完整的链路：
- createReactApp 创建应用实例
- connectReactPage 连接 React 组件与小程序页面
- createPageConfig 处理页面配置和生命周期
- performUpdate 统一处理数据更新
- setData 同步到小程序层
这样的设计确保了 React 组件和小程序页面之间的数据能够保持同步，同时保持了各自的生命周期管理。

### AppWrapper 是怎么维护页面栈的，小程序页面切换的时候，如何获取页面栈中的数据？这里有没有 app.js 和 page 的共享数据

从代码中可以分析出 AppWrapper 维护页面栈的机制：
1. AppWrapper 通过两个数组维护页面状态：
```js
        return class PageWrapper extends R.Component {
            static getDerivedStateFromError(error) {
                var _a, _b;
                (_b = (_a = _chunk_R2V3WQ7B_js__WEBPACK_IMPORTED_MODULE_0__.Current.app) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error.message + error.stack);
                return {
                    hasError: true
                };
                };
            // React 16 uncaught error 会导致整个应用 crash，
            // 目前把错误缩小到页面
            componentDidCatch(error, info) {
                if (true) {
                    console.warn(error);
                    console.error(info.componentStack);
                }
                }
            render() {
                const children = this.state.hasError ? [] : h$1(reactMeta.PageContext.Provider, {
                    value: id
                }, h$1(Page, Object.assign(Object.assign({}, this.props), refs)));
                if (false) {} else {
                    return h$1("root", {
```
this.pages: 存储待渲染的页面组件

this.elements: 存储已渲染的页面元素
2. 页面切换时的数据处理：
```js
function createPageConfig(component, pageName, data, pageConfig) {
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.hooks.call("getMiniLifecycleImpl").page;
    let pageElement = null;
    let unmounting = false;
    let prepareMountList = [];
    function setCurrentRouter(page) {
        const router =  false ? 0 : page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!(0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    let loadResolver;
    let hasLoaded;
    const config = {
        [ONLOAD] (options2 = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            perf.start(PAGE_INIT);
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options2, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (false) {}
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            if (true) {
                window2.trigger(CONTEXT_ACTIONS.INIT, $taroPath);
            }
            const mount = ()=>{
                Current.app.mount(component, $taroPath, ()=>{
                    pageElement = env.document.getElementById($taroPath);
                    (0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.ensure)(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                    safeExecute($taroPath, ON_LOAD, this.$taroParams);
                    loadResolver();
                    if (true) {
                        pageElement.ctx = this;
                        pageElement.performUpdate(true, cb);
                    } else {}
                });
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        }
```
在 createPageConfig 中，通过 Current 对象维护当前页面的状态：
- Current.page: 当前页面实例
- Current.router: 当前路由信息
- Current.app: 应用实例
3. 页面间共享数据的方式：
   a. 通过 Current 对象：
```js
    function setCurrentRouter(page) {
        const router =  false ? 0 : page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!(0,_chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
```
Current 对象作为全局状态管理器，可以在不同页面间共享数据。

b. 通过 PageContext, React 的 Context 机制用于跨组件传递数据。
```js
if (reactMeta.PageContext === _chunk_KEK4XUFF_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY_OBJ) {
reactMeta.PageContext = R.createContext("");
}
```

![img.png](img.png)
