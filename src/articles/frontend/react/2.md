---
title: "React 状态更新流程"
subTitle: "基于 v19.2.0 版本"
author: oasis
tags: [React]
---

本文通过下述 Demo 分析 React v19.2.0 的状态更新流程。

```jsx

import { useState } from 'react'
import { createRoot } from 'react-dom/client'

function App() {
    // 断点 1: useState 初始化
    debugger;
    const [count, setCount] = useState(0);

    // 断点 2: 组件渲染
    console.log('渲染次数:', count);

    const handleClick = () => {
        // 断点 3: setState 调用
        debugger;
        setCount(count + 1);
        // 断点 4: setState 调用后（注意：此时 count 还未更新）
        debugger;
    };

    return (
        <div>
            <h1>状态更新流程</h1>
            <p onClick={handleClick}>观察 setState 如何触发更新流程, {count}</p>
        </div>
    );
}

debugger;
const root = createRoot(document.getElementById('root'));

debugger;
root.render(<App />);
```

## useState(0) 的执行过程

在创建 App Fiber 的时候，会执行 `renderWithHooks`，之后调用 App 函数，触发 useState 的执行

```typescript
export function useState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  const dispatcher = resolveDispatcher();
    // initialState = 0
  return dispatcher.useState(initialState);
}
```
resolveDispatcher 会返回 packages/shared/ReactSharedInternals.js 中的 React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;

__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE 实际上是 ReactSharedInternals。

```typescript
const ReactSharedInternals: SharedStateClient = ({
                                                     H: null,
                                                     A: null,
                                                     T: null,
                                                     S: null,
                                                 }: any);
```

ReactSharedInternals.H 在 renderWithHooks 中被赋值。

```typescript
function renderWithHooks() {
    ReactSharedInternals.H = HooksDispatcherOnMountInDEV
}
```

所以 resolveDispathcer 返回了一个包含 useState 方法的对象。

useState 方法中调用 mountState(initialState) 设置 workInProgressHook。并将 workInProgressFiler 和 queue 绑定到 dispatchSetState。
然后返回状态值和绑定后的 dispatch。

```typescript
// The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.
let currentlyRenderingFiber: Fiber = (null: any);
let workInProgressHook: Hook | null = null;  // 存储当前的 Hooks

function mountState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
    // hook 变量实际指向 workInProgressHook
  const hook = mountStateImpl(initialState);
  const queue = hook.queue;
  const dispatch: Dispatch<BasicStateAction<S>> = (dispatchSetState.bind(
    null,
    currentlyRenderingFiber,// workInProgressFiber
    queue,
  ): any);
  queue.dispatch = dispatch;
  return [hook.memoizedState, dispatch];
}

function mountStateImpl<S>(initialState: (() => S) | S): Hook {
    const hook = mountWorkInProgressHook();
    if (typeof initialState === 'function') {
        const initialStateInitializer = initialState;
        // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
                // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types
                initialStateInitializer();
            } finally {
                setIsStrictModeForDevtools(false);
            }
        }
    }
    hook.memoizedState = hook.baseState = initialState;
    const queue: UpdateQueue<S, BasicStateAction<S>> = {
        pending: null,
        lanes: NoLanes,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: (initialState: any),
    };
    hook.queue = queue;
    return hook;
}
function mountWorkInProgressHook(): Hook {
  const hook: Hook = {
    memoizedState: null,

    baseState: null,
    baseQueue: null,
    queue: null,

    next: null,
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

workInProgressHook 的内存结构如下：

![workInProgressHook](/images/react/React-2-1.png)



## setCount(count + 1) 的执行过程

当点击 p 元素，触发 dispatchSetState 方法（它已经绑定了正确的 FiberNode 和 queue）。对于本文中的 demo ，dispatchSetState 执行的时候，fiber 是 App 的 FiberNode。

```typescript
function dispatchSetStateInternal<S, A>(
    fiber: Fiber,
    queue: UpdateQueue<S, A>,
    action: A,
    lane: Lane,
): boolean {
    const update: Update<S, A> = {
        lane,
        revertLane: NoLane,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: (null: any),
    };
    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (root !== null) {
        scheduleUpdateOnFiber(root, fiber, lane);
        entangleTransitionUpdate(root, queue, lane);
        return true;
    }
}
```

enqueueConcurrentHookUpdate(fiber, queue, update, lane) 找到需要更新的 Root。然后通过 scheduleUpdateOnFiber 启动 Root 的调度。

此时 Root 的 pendingLanes 为 2。

attemptEarlyBailoutIfNoScheduledUpdate()
bailoutOnAlreadyFinishedWork()
updateFunctionComponent()
finishRenderingHooks()
useFiber()
createWorkInProgress()