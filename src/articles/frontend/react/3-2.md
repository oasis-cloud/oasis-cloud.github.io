---
title: "Untitled"
author: oasis
date: 2025-11-30
---

# React Scheduler 执行入口和执行流程详解

## 一、执行入口

### 1.1 主要入口函数

React Scheduler 的核心入口函数是 **`unstable_scheduleCallback`**，这是外部（主要是 React Reconciler）调度任务的主要接口。

```327:416:packages/scheduler/src/forks/Scheduler.js
function unstable_scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: Callback,
  options?: {delay: number},
): Task {
  var currentTime = getCurrentTime();

  var startTime;
  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;
    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      // Times out immediately
      timeout = -1;
      break;
    case UserBlockingPriority:
      // Eventually times out
      timeout = userBlockingPriorityTimeout;
      break;
    case IdlePriority:
      // Never times out
      timeout = maxSigned31BitInt;
      break;
    case LowPriority:
      // Eventually times out
      timeout = lowPriorityTimeout;
      break;
    case NormalPriority:
    default:
      // Eventually times out
      timeout = normalPriorityTimeout;
      break;
  }

  var expirationTime = startTime + timeout;

  var newTask: Task = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };
  if (enableProfiling) {
    newTask.isQueued = false;
  }

  if (startTime > currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // All tasks are delayed, and this is the task with the earliest delay.
      if (isHostTimeoutScheduled) {
        // Cancel an existing timeout.
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      // Schedule a timeout.
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    if (enableProfiling) {
      markTaskStart(newTask, currentTime);
      newTask.isQueued = true;
    }
    // Schedule a host callback, if needed. If we're already performing work,
    // wait until the next time we yield.
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback();
    }
  }

  return newTask;
}
```

### 1.2 调用链入口

从 React Reconciler 的调用链：

```
React Reconciler (ReactFiberRootScheduler.js)
  ↓
scheduleCallback() 
  ↓
Scheduler.unstable_scheduleCallback()
  ↓
unstable_scheduleCallback() [Scheduler.js]
```

## 二、完整执行流程

### 2.1 流程图

```
┌─────────────────────────────────────────────────────────────┐
│  1. React Reconciler 调用 scheduleCallback()                │
│     - 传入优先级和回调函数                                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  2. unstable_scheduleCallback()                            │
│     - 创建 Task 对象                                        │
│     - 计算 expirationTime（过期时间）                       │
│     - 根据 startTime 决定放入哪个队列：                      │
│       • startTime > currentTime → timerQueue（延迟任务）    │
│       • startTime <= currentTime → taskQueue（立即任务）   │
└────────────────────┬────────────────────────────────────────┘
                     │
         ┌───────────┴───────────┐
         │                       │
         ▼                       ▼
┌──────────────────┐   ┌──────────────────────┐
│ 延迟任务          │   │ 立即任务              │
│ timerQueue       │   │ taskQueue            │
│                  │   │                      │
│ requestHostTimeout│   │ requestHostCallback()│
│ (handleTimeout)  │   │                      │
└────────┬─────────┘   └──────────┬───────────┘
         │                        │
         │                        │
         └───────────┬────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  3. requestHostCallback()                                  │
│     - 设置 isMessageLoopRunning = true                     │
│     - 调用 schedulePerformWorkUntilDeadline()              │
│       • Node.js: setImmediate()                            │
│       • 浏览器: MessageChannel.postMessage()              │
│       • 回退: setTimeout()                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  4. performWorkUntilDeadline() [异步执行]                   │
│     - 记录开始时间 startTime                                │
│     - 调用 flushWork(currentTime)                          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  5. flushWork(initialTime)                                 │
│     - 设置 isPerformingWork = true                         │
│     - 调用 workLoop(initialTime)                           │
│     - 清理状态和标记                                        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  6. workLoop(currentTime) [核心工作循环]                     │
│     - advanceTimers(): 将到期的延迟任务移到 taskQueue       │
│     - 循环处理 taskQueue 中的任务：                        │
│       ① peek(taskQueue) 获取最高优先级任务                  │
│       ② 检查是否应该让出控制权 (shouldYieldToHost)         │
│       ③ 执行任务的 callback                                │
│       ④ 如果 callback 返回 continuation，继续调度         │
│       ⑤ 任务完成后从队列移除                               │
│     - 返回是否有更多工作 (hasMoreWork)                     │
└────────────────────┬────────────────────────────────────────┘
                     │
         ┌───────────┴───────────┐
         │                       │
    hasMoreWork=true      hasMoreWork=false
         │                       │
         ▼                       ▼
┌──────────────────┐   ┌──────────────────────┐
│ 继续调度          │   │ 停止工作循环          │
│ schedulePerform  │   │ isMessageLoopRunning │
│ WorkUntilDeadline│   │ = false              │
└──────────────────┘   └──────────────────────┘
```

### 2.2 关键函数详解

#### 2.2.1 `requestHostCallback()` - 请求主机回调

```544:549:packages/scheduler/src/forks/Scheduler.js
function requestHostCallback() {
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    schedulePerformWorkUntilDeadline();
  }
}
```

**作用**：启动消息循环，通过平台 API（setImmediate/MessageChannel/setTimeout）异步执行工作。

#### 2.2.2 `performWorkUntilDeadline()` - 执行工作直到截止时间

```485:510:packages/scheduler/src/forks/Scheduler.js
const performWorkUntilDeadline = () => {
  if (enableRequestPaint) {
    needsPaint = false;
  }
  if (isMessageLoopRunning) {
    const currentTime = getCurrentTime();
    // 记录开始时间，以便我们可以测量主线程被阻塞了多长时间。
    startTime = currentTime;

    // 如果调度器任务抛出错误，退出当前浏览器任务，以便可以观察到错误。
    //
    // 故意不使用 try-catch，因为这会使某些调试技术变得更困难。
    // 相反，如果 `flushWork` 出错，那么 `hasMoreWork` 将保持为 true，我们会继续工作循环。
    let hasMoreWork = true;
    try {
      hasMoreWork = flushWork(currentTime);
    } finally {
      if (hasMoreWork) {
        // 如果还有更多工作，在前一个消息事件的末尾调度下一个消息事件。
        schedulePerformWorkUntilDeadline();
      } else {
        isMessageLoopRunning = false;
      }
    }
  }
};
```

**作用**：
- 记录开始时间
- 调用 `flushWork` 执行实际工作
- 根据返回值决定是否继续调度

#### 2.2.3 `flushWork()` - 刷新工作

```144:186:packages/scheduler/src/forks/Scheduler.js
function flushWork(initialTime: number) {
  if (enableProfiling) {
    markSchedulerUnsuspended(initialTime);
  }

  // We'll need a host callback the next time work is scheduled.
  isHostCallbackScheduled = false;
  if (isHostTimeoutScheduled) {
    // We scheduled a timeout but it's no longer needed. Cancel it.
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  try {
    if (enableProfiling) {
      try {
        return workLoop(initialTime);
      } catch (error) {
        if (currentTask !== null) {
          const currentTime = getCurrentTime();
          // $FlowFixMe[incompatible-call] found when upgrading Flow
          markTaskErrored(currentTask, currentTime);
          // $FlowFixMe[incompatible-use] found when upgrading Flow
          currentTask.isQueued = false;
        }
        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
    if (enableProfiling) {
      const currentTime = getCurrentTime();
      markSchedulerSuspended(currentTime);
    }
  }
}
```

**作用**：
- 设置工作状态标志
- 调用 `workLoop` 执行工作循环
- 清理状态和错误处理

#### 2.2.4 `workLoop()` - 核心工作循环

```188:258:packages/scheduler/src/forks/Scheduler.js
function workLoop(initialTime: number) {
  let currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);
  while (currentTask !== null) {
    if (!enableAlwaysYieldScheduler) {
      if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {
        // This currentTask hasn't expired, and we've reached the deadline.
        break;
      }
    }
    // $FlowFixMe[incompatible-use] found when upgrading Flow
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      currentTask.callback = null;
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      currentPriorityLevel = currentTask.priorityLevel;
      // $FlowFixMe[incompatible-use] found when upgrading Flow
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      if (enableProfiling) {
        // $FlowFixMe[incompatible-call] found when upgrading Flow
        markTaskRun(currentTask, currentTime);
      }
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      if (typeof continuationCallback === 'function') {
        // If a continuation is returned, immediately yield to the main thread
        // regardless of how much time is left in the current time slice.
        // $FlowFixMe[incompatible-use] found when upgrading Flow
        currentTask.callback = continuationCallback;
        if (enableProfiling) {
          // $FlowFixMe[incompatible-call] found when upgrading Flow
          markTaskYield(currentTask, currentTime);
        }
        advanceTimers(currentTime);
        return true;
      } else {
        if (enableProfiling) {
          // $FlowFixMe[incompatible-call] found when upgrading Flow
          markTaskCompleted(currentTask, currentTime);
          // $FlowFixMe[incompatible-use] found when upgrading Flow
          currentTask.isQueued = false;
        }
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
        advanceTimers(currentTime);
      }
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
    if (enableAlwaysYieldScheduler) {
      if (currentTask === null || currentTask.expirationTime > currentTime) {
        // This currentTask hasn't expired we yield to the browser task.
        break;
      }
    }
  }
  // Return whether there's additional work
  if (currentTask !== null) {
    return true;
  } else {
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
```

**核心逻辑**：
1. **advanceTimers()**: 将到期的延迟任务从 `timerQueue` 移到 `taskQueue`
2. **循环处理任务**：
    - 从 `taskQueue` 获取最高优先级任务（最小堆的根节点）
    - 检查是否应该让出控制权（`shouldYieldToHost()`）
    - 执行任务的 `callback`
    - 如果返回 `continuation`，继续调度
    - 任务完成后从队列移除
3. **返回状态**：是否有更多工作需要处理

#### 2.2.5 `advanceTimers()` - 推进定时器

```103:125:packages/scheduler/src/forks/Scheduler.js
function advanceTimers(currentTime: number) {
  // Check for tasks that are no longer delayed and add them to the queue.
  let timer = peek(timerQueue);
  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // Timer fired. Transfer to the task queue.
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
      if (enableProfiling) {
        markTaskStart(timer, currentTime);
        timer.isQueued = true;
      }
    } else {
      // Remaining timers are pending.
      return;
    }
    timer = peek(timerQueue);
  }
}
```

**作用**：将到期的延迟任务从 `timerQueue` 转移到 `taskQueue`，使其可以被执行。

#### 2.2.6 `shouldYieldToHost()` - 是否应该让出控制权

```447:460:packages/scheduler/src/forks/Scheduler.js
function shouldYieldToHost(): boolean {
  if (!enableAlwaysYieldScheduler && enableRequestPaint && needsPaint) {
    // Yield now.
    return true;
  }
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed < frameInterval) {
    // The main thread has only been blocked for a really short amount of time;
    // smaller than a single frame. Don't yield yet.
    return false;
  }
  // Yield now.
  return true;
}
```

**作用**：检查是否应该让出控制权给浏览器，避免长时间阻塞主线程。

## 三、数据结构

### 3.1 两个优先级队列

1. **`taskQueue`** - 立即执行的任务队列（最小堆）
    - 按 `expirationTime` 排序
    - 使用最小堆快速获取最高优先级任务

2. **`timerQueue`** - 延迟任务队列（最小堆）
    - 按 `startTime` 排序
    - 到期后转移到 `taskQueue`

### 3.2 Task 对象结构

```47:57:packages/scheduler/src/forks/Scheduler.js
export opaque type Task = {
  id: number,
  callback: Callback | null,
  priorityLevel: PriorityLevel,
  startTime: number,
  expirationTime: number,
  sortIndex: number,
  isQueued?: boolean,
};
```

## 四、执行示例

### 4.1 典型执行流程示例

```javascript
// 1. React Reconciler 调度任务
scheduleCallback(NormalPriority, () => {
  performWorkOnRoot(root);
});

// 2. Scheduler 内部流程
// - unstable_scheduleCallback() 创建 Task
// - push(taskQueue, task)
// - requestHostCallback()
// - schedulePerformWorkUntilDeadline() (使用 MessageChannel)
// - performWorkUntilDeadline() 异步执行
// - flushWork()
// - workLoop()
//   - advanceTimers()
//   - 循环执行 taskQueue 中的任务
//   - 执行 callback: performWorkOnRoot()
//   - 检查 shouldYieldToHost()
//   - 返回 hasMoreWork
```

### 4.2 时间切片（Time Slicing）

Scheduler 通过 `shouldYieldToHost()` 实现时间切片：
- 每次执行任务前检查是否超过时间限制（`frameInterval`）
- 如果超过，让出控制权，让浏览器处理其他任务
- 下次通过 `schedulePerformWorkUntilDeadline()` 继续执行

## 五、关键设计点

1. **异步执行**：使用 MessageChannel/setImmediate/setTimeout 实现异步调度
2. **优先级队列**：使用最小堆快速获取最高优先级任务
3. **时间切片**：通过 `shouldYieldToHost()` 避免长时间阻塞主线程
4. **延迟任务**：支持延迟执行的任务（`timerQueue`）
5. **任务延续**：支持任务返回 continuation callback 继续执行

## 六、总结

React Scheduler 的执行流程是一个**事件驱动的异步任务调度系统**：

1. **入口**：`unstable_scheduleCallback()` 接收任务并加入队列
2. **调度**：`requestHostCallback()` 启动异步执行
3. **执行**：`performWorkUntilDeadline()` → `flushWork()` → `workLoop()`
4. **循环**：`workLoop()` 循环处理任务，直到队列为空或需要让出控制权
5. **让出**：通过 `shouldYieldToHost()` 检查，必要时让出控制权给浏览器

这个设计使得 React 能够高效地调度和执行任务，同时保持应用的响应性。

