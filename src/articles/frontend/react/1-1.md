---
title: "Untitled"
author: oasis
date: 2025-11-27
---

# React 基础初始化流程详解

## 概述

React 的初始化是一个复杂的过程，涉及 Fiber 架构、调度系统、协调算法等多个核心机制。本文将从源码角度深入解析 React 的初始化流程，结合 Fiber 树的结构和工作循环机制，帮助理解 React 如何将组件树渲染到页面上。

## 一、初始化入口：创建 FiberRoot

### 1.1 createRoot / hydrateRoot

当我们调用 `createRoot()` 或 `hydrateRoot()` 时，React 首先会创建一个 `FiberRoot` 节点：

```typescript
// ReactFiberReconciler.js
export function createRoot(
  containerInfo: Container,
  tag: RootTag,
  // ... 其他参数
): OpaqueRoot {
  const root = createFiberRoot(
    containerInfo,
    tag,
    hydrate: false,
    initialChildren,
    // ...
  );
  
  // 调度初始渲染
  scheduleInitialHydrationOnRoot(root, lane);
  return root;
}
```

**关键点：**
- `FiberRoot` 是整个应用的根节点，包含 `containerInfo`（DOM 容器）
- `root.current` 指向根 Fiber 节点（HostRoot）
- 创建后立即调度初始渲染

### 1.2 FiberRoot 结构

```typescript
// ReactFiberRoot.js
function FiberRootNode(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  // ...
) {
  this.tag = tag;
  this.containerInfo = containerInfo;
  this.current = null;  // 指向根 Fiber 节点
  this.pendingLanes = NoLanes;
  this.finishedLanes = NoLanes;
  this.callbackNode = null;
  this.callbackPriority = NoLane;
  // ...
}
```

## 二、Fiber 节点的创建与初始化

### 2.1 创建根 Fiber 节点

在 `createFiberRoot` 中，会创建根 Fiber 节点：

```typescript
// ReactFiberRoot.js
export function createFiberRoot(
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  initialChildren: ReactNodeList,
  // ...
): FiberRoot {
  const root: FiberRoot = (new FiberRootNode(/*...*/): any);
  
  // 创建根 Fiber 节点（HostRoot）
  const uninitializedFiber = createFiber(HostRoot, null, null, NoMode);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  
  // 初始化更新队列
  initializeUpdateQueue(uninitializedFiber);
  
  return root;
}
```

**关键点：**
- 根 Fiber 节点的 `tag` 是 `HostRoot`
- `root.current` 和 `uninitializedFiber.stateNode` 相互引用
- 初始化更新队列，用于存储根节点的更新

### 2.2 Fiber 节点的基本结构

```typescript
// ReactFiber.js
const fiber: Fiber = {
  // 节点类型和标识
  tag: WorkTag,
  key: null | string,
  elementType: any,
  type: any,
  
  // 状态节点（DOM 节点或组件实例）
  stateNode: any,
  
  // Fiber 树结构
  return: null,      // 指向父节点
  child: null,       // 指向第一个子节点
  sibling: null,     // 指向下一个兄弟节点
  index: 0,
  
  // 状态和更新
  memoizedProps: null,
  memoizedState: null,
  updateQueue: null,
  
  // 优先级和标志
  lanes: NoLanes,
  childLanes: NoLanes,
  flags: NoFlags,
  subtreeFlags: NoFlags,
  
  // 双缓冲
  alternate: null,
  
  // ...
};
```

## 三、更新队列的初始化

### 3.1 initializeUpdateQueue

```typescript
// ReactFiberClassUpdateQueue.js
export function initializeUpdateQueue<State>(fiber: Fiber): void {
  const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,  // 环形链表，存储待处理的更新
      lanes: NoLanes,
      hiddenCallbacks: null,
    },
    callbacks: null,
  };
  fiber.updateQueue = queue;
}
```

**更新队列结构：**
- `baseState`: 基础状态，所有更新都基于此状态计算
- `shared.pending`: 环形链表，存储所有待处理的更新
- `firstBaseUpdate` / `lastBaseUpdate`: 已处理的更新链表

### 3.2 创建初始更新

```typescript
// ReactFiberReconciler.js - createRoot
const current = root.current;
const lane = requestUpdateLane(current);
const update = createUpdate(lane);
update.callback = callback;
enqueueUpdate(current, update, lane);
```

**更新对象结构：**
```typescript
type Update<State> = {
  lane: Lane,
  tag: 0 | 1 | 2 | 3,  // UpdateState, ReplaceState, ForceUpdate, CaptureUpdate
  payload: any,
  callback: (() => mixed) | null,
  next: Update<State> | null,  // 链表指针
};
```

## 四、调度初始渲染

### 4.1 scheduleInitialHydrationOnRoot

```typescript
// ReactFiberWorkLoop.js
export function scheduleInitialHydrationOnRoot(root: FiberRoot, lane: Lane) {
  const current = root.current;
  current.lanes = lane;
  markRootUpdated(root, lane);
  ensureRootIsScheduled(root);
}
```

**流程：**
1. 将 lane 标记到根 Fiber 节点
2. 标记根节点有更新
3. 确保根节点被调度

### 4.2 ensureRootIsScheduled

```typescript
// ReactFiberRootScheduler.js
export function ensureRootIsScheduled(root: FiberRoot): void {
  // 1. 将根节点加入调度队列
  if (root === lastScheduledRoot || root.next !== null) {
    // 已经在队列中
  } else {
    if (lastScheduledRoot === null) {
      firstScheduledRoot = lastScheduledRoot = root;
    } else {
      lastScheduledRoot.next = root;
      lastScheduledRoot = root;
    }
  }
  
  // 2. 确保有微任务来处理调度队列
  ensureScheduleIsScheduled();
}
```

### 4.3 微任务调度

```typescript
// ReactFiberRootScheduler.js
function scheduleImmediateRootScheduleTask() {
  if (supportsMicrotasks) {
    scheduleMicrotask(() => {
      processRootScheduleInMicrotask();
    });
  }
}
```

**关键点：**
- 使用微任务确保在当前事件循环结束后处理更新
- 避免在事件处理过程中触发渲染

## 五、工作循环的开始

### 5.1 prepareFreshStack

当开始新的渲染时，会调用 `prepareFreshStack` 准备新的工作栈：

```typescript
// ReactFiberWorkLoop.js
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  resetWorkInProgressStack();
  workInProgressRoot = root;
  
  // 创建或复用根节点的 workInProgress
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;  // ⭐ 关键赋值
  
  workInProgressRootRenderLanes = lanes;
  // ... 重置其他状态
  return rootWorkInProgress;
}
```

**关键操作：**
- `workInProgress` 被设置为根节点的 workInProgress（可能是新创建或复用的）
- 这是工作循环的起点

### 5.2 createWorkInProgress：复用优先，按需创建

**重要：`prepareFreshStack` 不是每次都创建新的 WIP 树，而是优先复用已有的 alternate！**

```typescript
// ReactFiber.js
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;  // ⭐ 首先尝试获取已有的 alternate
  
  if (workInProgress === null) {
    // 情况1：没有 alternate，创建新的（首次渲染或 alternate 被清理）
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse.
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    
    // 建立双向引用
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // 情况2：已有 alternate，复用并重置（常见情况）
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    
    // 重置效果标志
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
    
    // 重置性能计时器
    if (enableProfilerTimer) {
      workInProgress.actualDuration = -0;
      workInProgress.actualStartTime = -1.1;
    }
  }
  
  // 无论新创建还是复用，都需要复制当前状态
  workInProgress.flags = current.flags & StaticMask;  // 保留静态标志
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  
  return workInProgress;
}
```

**双缓冲机制详解：**

1. **首次渲染**：
    - `current.alternate === null`
    - 创建新的 `workInProgress` Fiber
    - 建立 `current ↔ workInProgress` 的双向引用

2. **后续更新**（常见情况）：
    - `current.alternate !== null`（存在上次的 workInProgress）
    - **复用**已有的 `workInProgress`，只重置必要的属性
    - 避免频繁创建/销毁对象，提升性能

3. **为什么只需要两个版本？**
    - React 使用双缓冲技术：只需要 `current` 和 `workInProgress` 两棵树
    - 提交后，`workInProgress` 成为新的 `current`
    - 旧的 `current` 成为新的 `workInProgress`（通过 `alternate` 引用）
    - 这样可以在两棵树之间来回切换，无需创建第三棵树

**生命周期示例：**

```
首次渲染：
  current (null) → createWorkInProgress → workInProgress (新建)
  
第一次更新：
  current (已提交) ←alternate→ workInProgress (复用)
  
提交后：
  current (原 workInProgress) ←alternate→ workInProgress (原 current)
  
第二次更新：
  current (已提交) ←alternate→ workInProgress (复用，重置属性)
```

**性能优化：**
- 复用已有的 Fiber 节点，减少内存分配
- 只重置必要的属性，保留可复用的数据
- 通过对象池技术，避免频繁的 GC

## 六、协调过程（Reconciliation）

### 6.1 工作循环

```typescript
// ReactFiberWorkLoop.js
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;
  let next;
  
  // beginWork: 处理当前节点，返回子节点
  next = beginWork(current, unitOfWork, renderLanes);
  
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  
  if (next === null) {
    // 没有子节点，完成当前节点
    completeUnitOfWork(unitOfWork);
  } else {
    // 有子节点，移动到子节点
    workInProgress = next;  // ⭐ 移动到子节点
  }
}
```

### 6.2 beginWork：处理节点

```typescript
// ReactFiberBeginWork.js
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 清除待处理的更新优先级
  workInProgress.lanes = NoLanes;
  
  switch (workInProgress.tag) {
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case FunctionComponent:
      return updateFunctionComponent(current, workInProgress, renderLanes);
    case ClassComponent:
      return updateClassComponent(current, workInProgress, renderLanes);
    // ... 其他类型
  }
}
```

### 6.3 reconcileChildren：协调子节点

```typescript
// ReactFiberBeginWork.js
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes,
) {
  if (current === null) {
    // 首次渲染：创建新的子节点
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 更新：协调新旧子节点
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

**关键点：**
- `workInProgress.child` 被设置为第一个子节点
- 子节点通过 `sibling` 指针连接成链表

### 6.4 设置 return 和 sibling

在 `reconcileChildFibers` 中：

```typescript
// ReactChildFiber.js
function reconcileChildrenArray(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChildren: Array<any>,
  lanes: Lanes,
): Fiber | null {
  let resultingFirstChild: Fiber | null = null;
  let previousNewFiber: Fiber | null = null;
  
  for (let i = 0; i < newChildren.length; i++) {
    const newFiber = updateSlot(returnFiber, oldFiber, newChildren[i], lanes);
    
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;  // 第一个子节点
    } else {
      previousNewFiber.sibling = newFiber;  // ⭐ 设置 sibling
    }
    
    newFiber.return = returnFiber;  // ⭐ 设置 return
    previousNewFiber = newFiber;
  }
  
  return resultingFirstChild;
}
```

## 七、完成阶段（Complete Phase）

### 7.1 completeUnitOfWork

```typescript
// ReactFiberWorkLoop.js
function completeUnitOfWork(unitOfWork: Fiber): void {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    
    // completeWork: 完成当前节点的工作
    completeWork(current, completedWork, renderLanes);
    
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      // 有兄弟节点，处理兄弟节点
      workInProgress = siblingFiber;  // ⭐ 移动到兄弟节点
      return;
    }
    
    // 没有兄弟节点，返回到父节点
    completedWork = returnFiber;
    workInProgress = completedWork;  // ⭐ 移动到父节点
  } while (completedWork !== null);
}
```

### 7.2 completeWork

```typescript
// ReactFiberCompleteWork.js
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): null | Fiber {
  const newProps = workInProgress.pendingProps;
  
  switch (workInProgress.tag) {
    case HostComponent:
      // 创建 DOM 节点
      const instance = createInstance(workInProgress.type, newProps);
      workInProgress.stateNode = instance;
      // 标记需要插入
      workInProgress.flags |= Placement;
      break;
    // ... 其他类型
  }
  
  return null;
}
```

## 八、提交阶段（Commit Phase）

### 8.1 commitRootWhenReady

渲染完成后，检查是否可以提交：

```typescript
// ReactFiberWorkLoop.js
function commitRootWhenReady(
  root: FiberRoot,
  finishedWork: Fiber,
  // ...
) {
  // 检查是否需要等待（Suspense、View Transition 等）
  const maySuspendCommit = /* ... */;
  
  if (maySuspendCommit) {
    // 等待资源就绪
    const schedulePendingCommit = waitForCommitToBeReady(/*...*/);
    if (schedulePendingCommit !== null) {
      // 延迟提交
      root.cancelPendingCommit = schedulePendingCommit(commitRoot.bind(/*...*/));
      return;
    }
  }
  
  // 立即提交
  commitRoot(/*...*/);
}
```

### 8.2 commitRoot

```typescript
// ReactFiberWorkLoop.js
function commitRoot(
  root: FiberRoot,
  finishedWork: Fiber,
  lanes: Lanes,
  // ...
): void {
  // 1. 刷新被动效果
  flushPendingEffects();
  
  // 2. 标记根节点完成
  markRootFinished(root, lanes, remainingLanes);
  
  // 3. 重置工作状态
  workInProgressRoot = null;
  workInProgress = null;
  
  // 4. 执行提交的三个子阶段
  // - BeforeMutation: getSnapshotBeforeUpdate
  // - Mutation: 插入/更新/删除 DOM
  // - Layout: componentDidMount/Update, useLayoutEffect
  // - Passive: useEffect
}
```

### 8.3 commitPlacement

处理 DOM 节点的插入：

```typescript
// ReactFiberCommitHostEffects.js
function commitPlacement(finishedWork: Fiber): void {
  // 1. 向上查找宿主父节点
  let parentFiber = finishedWork.return;
  while (parentFiber !== null) {
    if (isHostParent(parentFiber)) {
      hostParentFiber = parentFiber;
      break;
    }
    parentFiber = parentFiber.return;
  }
  
  // 2. 获取插入位置
  const before = getHostSibling(finishedWork);
  
  // 3. 插入节点
  insertOrAppendPlacementNodeIntoContainer(
    finishedWork,
    before,
    parent,
    parentFragmentInstances,
  );
}
```

### 8.4 insertOrAppendPlacementNodeIntoContainer

```typescript
// ReactFiberCommitHostEffects.js
function insertOrAppendPlacementNodeIntoContainer(
  node: Fiber,
  before: ?Instance,
  parent: Container,
  parentFragmentInstances: null | Array<FragmentInstanceType>,
): void {
  const {tag} = node;
  const isHost = tag === HostComponent || tag === HostText;
  
  if (isHost) {
    // 直接插入宿主节点
    const stateNode = node.stateNode;
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
    return;
  }
  
  // 递归处理子节点
  const child = node.child;
  if (child !== null) {
    insertOrAppendPlacementNodeIntoContainer(child, before, parent, /*...*/);
    let sibling = child.sibling;
    while (sibling !== null) {
      insertOrAppendPlacementNodeIntoContainer(sibling, before, parent, /*...*/);
      sibling = sibling.sibling;
    }
  }
}
```

## 九、完整流程图

```
用户调用 createRoot()
  ↓
创建 FiberRoot 和根 Fiber 节点
  ↓
初始化更新队列 (initializeUpdateQueue)
  ↓
创建初始更新 (createUpdate + enqueueUpdate)
  ↓
调度初始渲染 (scheduleInitialHydrationOnRoot)
  ↓
ensureRootIsScheduled() → 加入调度队列
  ↓
微任务: processRootScheduleInMicrotask()
  ↓
scheduleTaskForRootDuringMicrotask() → 创建 Scheduler 任务
  ↓
MessageChannel.postMessage() → 异步执行
  ↓
performWorkUntilDeadline() → 执行工作循环
  ↓
performWorkOnRootViaSchedulerTask()
  ↓
performWorkOnRoot()
  ↓
prepareFreshStack() → 创建 workInProgress
  ↓
renderRootSync/Concurrent()
  ↓
workLoopSync/Concurrent()
  ↓
performUnitOfWork()
  ├─→ beginWork() → 处理节点，返回子节点
  │   ├─→ updateHostRoot() → 处理根节点
  │   ├─→ updateFunctionComponent() → 处理函数组件
  │   └─→ reconcileChildren() → 协调子节点
  │       ├─→ reconcileChildFibers()
  │       ├─→ 设置 return 属性
  │       ├─→ 设置 child 属性
  │       └─→ 设置 sibling 属性
  │
  └─→ completeUnitOfWork() → 完成节点
      ├─→ completeWork() → 创建 DOM 节点
      ├─→ 移动到兄弟节点 (workInProgress = sibling)
      └─→ 移动到父节点 (workInProgress = return)
  ↓
渲染完成 → commitRootWhenReady()
  ↓
commitRoot() → 执行提交
  ↓
commitMutationEffects() → Mutation 阶段
  ├─→ commitPlacement() → 处理插入
  └─→ insertOrAppendPlacementNodeIntoContainer() → 插入 DOM
  ↓
commitLayoutEffects() → Layout 阶段
  ↓
commitPassiveEffects() → Passive 阶段
  ↓
完成！DOM 已更新
```

## 十、关键数据结构关系

### 10.1 Fiber 树结构

```
FiberRoot
  └─→ root.current (HostRoot Fiber)
      ├─→ child (第一个子 Fiber)
      │   ├─→ return → root.current
      │   ├─→ sibling (下一个兄弟 Fiber)
      │   └─→ child (第一个子 Fiber)
      │       └─→ ...
      └─→ sibling → null
```

### 10.2 更新队列结构

```
Fiber.updateQueue
  ├─→ baseState: 基础状态
  ├─→ shared.pending: 环形链表
  │   └─→ Update1 → Update2 → Update3 → Update1 (环形)
  └─→ firstBaseUpdate → lastBaseUpdate: 已处理的更新链表
```

### 10.3 工作循环中的指针移动

```
初始: workInProgress = rootFiber
  ↓
beginWork() → 返回子节点
workInProgress = child
  ↓
completeUnitOfWork()
  ├─→ 有兄弟节点 → workInProgress = sibling
  └─→ 无兄弟节点 → workInProgress = return (父节点)
  ↓
继续循环...
```

## 十一、总结

React 的初始化流程可以概括为以下几个关键步骤：

1. **创建阶段**：创建 `FiberRoot` 和根 `Fiber` 节点，初始化更新队列
2. **调度阶段**：将更新加入调度队列，通过微任务触发工作循环
3. **渲染阶段**：
    - `prepareFreshStack`: 创建 `workInProgress` 树
    - `workLoop`: 遍历 Fiber 树
    - `beginWork`: 处理节点，构建子节点树
    - `completeWork`: 完成节点，创建 DOM 节点
4. **提交阶段**：
    - `commitRootWhenReady`: 检查是否可以提交
    - `commitRoot`: 执行提交
    - `commitPlacement`: 插入 DOM 节点

整个过程体现了 React 的核心设计思想：
- **双缓冲**：`current` 和 `workInProgress` 两棵树
- **可中断**：通过时间切片实现并发渲染
- **优先级调度**：通过 Lane 模型管理更新优先级
- **增量更新**：只更新变化的部分

理解这些机制有助于深入掌握 React 的工作原理，也能更好地进行性能优化和问题排查。

## 十二、常见问题解答

### Q: 每次在 `prepareFreshStack` 中都会创建一个新的 WIP 树吗？

**A: 不是的！** `prepareFreshStack` 会优先复用已有的 WIP 树，只有在必要时才创建新的。

**详细说明：**

1. **首次渲染时**：
    - `root.current.alternate === null`
    - 会创建新的 `workInProgress` Fiber 节点
    - 建立 `current ↔ workInProgress` 的双向引用

2. **后续更新时**（常见情况）：
    - `root.current.alternate !== null`（存在上次的 workInProgress）
    - **复用**已有的 `workInProgress` 节点
    - 只重置必要的属性（flags、subtreeFlags、deletions 等）
    - 复制当前状态（child、memoizedProps、memoizedState 等）

3. **为什么这样设计？**
    - **性能优化**：避免频繁创建/销毁对象，减少内存分配和 GC 压力
    - **双缓冲机制**：只需要两棵树（current 和 workInProgress），通过 `alternate` 指针来回切换
    - **对象池技术**：复用 Fiber 节点，提升性能

**代码验证：**

```typescript
// ReactFiber.js - createWorkInProgress
let workInProgress = current.alternate;  // ⭐ 首先尝试获取已有的
if (workInProgress === null) {
  // 只有没有 alternate 时才创建新的
  workInProgress = createFiber(/*...*/);
} else {
  // 复用已有的，只重置属性
  workInProgress.pendingProps = pendingProps;
  workInProgress.flags = NoFlags;
  // ...
}
```

**实际场景：**

```
场景1：首次渲染
  prepareFreshStack() 
  → createWorkInProgress(root.current, null)
  → current.alternate === null
  → 创建新的 workInProgress ✅

场景2：第二次更新
  prepareFreshStack()
  → createWorkInProgress(root.current, null)
  → current.alternate !== null (存在上次的 workInProgress)
  → 复用已有的 workInProgress，重置属性 ✅

场景3：提交后
  commitRoot()
  → root.current = finishedWork (原 workInProgress)
  → 现在 current.alternate 指向原 current
  → 下次更新时复用这个 alternate
```

**总结：**
- `prepareFreshStack` 不是每次都创建新树
- 优先复用已有的 `alternate`（双缓冲机制）
- 只有在首次渲染或 alternate 被清理时才创建新的
- 这是 React 性能优化的重要机制之一

