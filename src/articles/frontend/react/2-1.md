---
title: "Untitled"
author: oasis
date: 2025-11-29
---

## 初始渲染流程详解

### 1. 创建 Root 和 FiberRoot

当执行 `createRoot(document.getElementById('root'))` 时：

```typescript
// packages/react-dom/src/client/ReactDOMRoot.js
export function createRoot(
  container: Container,
  options?: CreateRootOptions,
): RootType {
  return createRootImpl(container, options);
}
```

**关键步骤：**
1. 创建 `FiberRoot` 节点（`createFiberRoot`）
2. 创建根 `Fiber` 节点（`HostRoot`）
3. 建立 `FiberRoot.current` 和 `Fiber.stateNode` 的双向引用
4. 初始化 `pendingLanes`、`finishedLanes` 等调度相关属性

### 2. 调用 root.render()

当执行 `root.render(<App />)` 时：

```typescript
// packages/react-dom/src/client/ReactDOMRoot.js
render(children: ReactNodeList): void {
  const root = this._internalRoot;
  updateContainer(children, root, null, null);
}
```

**流程：**
1. 调用 `updateContainer` 创建更新对象
2. 将更新对象加入 `HostRoot` Fiber 的更新队列
3. 调用 `scheduleUpdateOnFiber` 调度更新

### 3. 调度初始渲染

```typescript
// packages/react-reconciler/src/ReactFiberWorkLoop.js
export function scheduleUpdateOnFiber(
  root: FiberRoot,
  fiber: Fiber,
  lane: Lane,
) {
  // 标记 root 有待处理的更新
  markRootUpdated(root, lane);
  
  // 确保 root 被调度
  ensureRootIsScheduled(root);
}
```

**关键点：**
- `markRootUpdated` 将 lane 添加到 `root.pendingLanes`
- `ensureRootIsScheduled` 通过调度器（scheduler）安排渲染任务
- 对于同步更新，会调用 `performSyncWorkOnRoot`

### 4. 准备渲染栈

```typescript
// packages/react-reconciler/src/ReactFiberWorkLoop.js
function renderRootSync(
  root: FiberRoot,
  lanes: Lanes,
): RootExitStatus {
  // 如果 root 或 lanes 改变，准备新的工作栈
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
  }
  
  // 执行同步工作循环
  workLoopSync();
}
```

**`prepareFreshStack` 的作用：**
1. 创建 `workInProgress` Fiber（从 `root.current` 克隆）
2. 重置工作循环相关变量
3. 设置 `workInProgressRoot` 和 `workInProgressRootRenderLanes`

### 5. 工作循环（Render 阶段）

```typescript
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;
  let next;
  
  // Begin 阶段：处理当前节点，返回子节点
  next = beginWork(current, unitOfWork, subtreeRenderLanes);
  
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  
  if (next === null) {
    // 没有子节点，进入 Complete 阶段
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}
```

**处理顺序（深度优先）：**
1. **HostRoot Fiber** → `updateHostRoot`
    - 处理根节点的更新队列
    - 协调子节点（`reconcileChildren`）
    - 返回 `App` Fiber

2. **App Fiber** → `updateFunctionComponent`
    - 调用 `renderWithHooks` 执行组件函数
    - 设置 `ReactSharedInternals.H = HooksDispatcherOnMount`
    - 执行 `App()` 函数，触发 `useState(0)`
    - `mountState` 创建 Hook 对象和更新队列
    - 返回 `[0, setCount]`
    - 协调子节点，返回 `div` Fiber

3. **div Fiber** → `updateHostComponent`
    - 协调子节点（`h1` 和 `p`）
    - 返回第一个子节点 `h1` Fiber

4. **h1 Fiber** → `updateHostComponent`
    - 协调文本节点
    - 返回文本节点 Fiber

5. **文本节点 Fiber** → `updateHostText`
    - 标记需要更新（`flags |= Update`）
    - 返回 `null`，进入 Complete 阶段

### 6. Complete 阶段

```typescript
function completeUnitOfWork(unitOfWork: Fiber): void {
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    
    // 完成当前节点的工作
    completeWork(current, completedWork, subtreeRenderLanes);
    
    // 移动到兄弟节点
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    
    // 没有兄弟节点，移动到父节点
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
```

**Complete 阶段的作用：**
1. 创建 DOM 节点（`createInstance`）
2. 设置 DOM 属性（`updateProperties`）
3. 将子节点添加到父节点（但不插入 DOM）
4. 向上冒泡 `subtreeFlags` 和 `childLanes`

### 7. Commit 阶段

渲染完成后，进入 Commit 阶段：

```typescript
function commitRoot(root: FiberRoot) {
  const finishedWork = root.finishedWork;
  
  // BeforeMutation 阶段
  commitBeforeMutationEffects(root, finishedWork);
  
  // Mutation 阶段：更新 DOM
  commitMutationEffects(root, finishedWork, committedLanes);
  
  // Layout 阶段：执行 layout effects
  commitLayoutEffects(finishedWork, root, committedLanes);
  
  // Passive 阶段：执行 passive effects（useEffect）
  schedulePassiveEffects(finishedWork);
}
```

**Commit 三个阶段：**
1. **BeforeMutation**：执行 `getSnapshotBeforeUpdate` 等
2. **Mutation**：插入/更新/删除 DOM 节点
3. **Layout**：执行 `useLayoutEffect` 和 ref 回调

---

## 点击事件后的更新流程详解

### 1. 事件触发

当用户点击 `<p>` 元素时，触发 `handleClick` 函数：

```jsx
const handleClick = () => {
  setCount(count + 1);  // count 此时为 0
};
```

### 2. dispatchSetState 调用

`setCount` 实际上是 `dispatchSetState`，它已经绑定了 `App` Fiber 和对应的 `queue`：

```typescript
// packages/react-reconciler/src/ReactFiberHooks.js
function dispatchSetState<S, A>(
  fiber: Fiber,
  queue: UpdateQueue<S, A>,
  action: A,
): void {
  const lane = requestUpdateLane(fiber);
  dispatchSetStateInternal(fiber, queue, action, lane);
}
```

**关键点：**
- `fiber` 是 `App` 的 Fiber 节点
- `queue` 是 `useState` 创建的更新队列
- `action` 是 `count + 1`（即 `1`）

### 3. 创建更新对象

```typescript
function dispatchSetStateInternal<S, A>(
  fiber: Fiber,
  queue: UpdateQueue<S, A>,
  action: A,
  lane: Lane,
): boolean {
  const update: Update<S, A> = {
    lane,
    revertLane: NoLane,
    gesture: null,
    action,  // count + 1
    hasEagerState: false,
    eagerState: null,
    next: null,
  };
  
  // 将更新加入队列
  const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
  
  if (root !== null) {
    scheduleUpdateOnFiber(root, fiber, lane);
    return true;
  }
}
```

**更新对象结构：**
- `lane`：优先级车道
- `action`：更新函数或值（这里是 `1`）
- `next`：指向下一个更新（形成链表）

### 4. 调度更新

```typescript
function scheduleUpdateOnFiber(
  root: FiberRoot,
  fiber: Fiber,
  lane: Lane,
) {
  // 标记 root 有更新
  markRootUpdated(root, lane);
  
  // 确保 root 被调度
  ensureRootIsScheduled(root);
}
```

**关键点：**
- `markRootUpdated` 将 lane 添加到 `root.pendingLanes`
- 对于同步更新，会立即调用 `performSyncWorkOnRoot`

### 5. 重新进入渲染流程

更新流程与初始渲染类似，但有以下区别：

#### 5.1 prepareFreshStack

```typescript
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  // 从 root.current 克隆创建 workInProgress
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  
  const timeoutHandle = root.timeoutHandle;
  if (timeoutHandle !== noTimeout) {
    root.timeoutHandle = noTimeout;
    cancelTimeout(timeoutHandle);
  }
  
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRoot = root;
  workInProgressRootRenderLanes = lanes;
  
  return workInProgress;
}
```

#### 5.2 beginWork 处理 App Fiber

```typescript
function updateFunctionComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes,
) {
  // 调用 renderWithHooks
  const nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes,
  );
  
  // 协调子节点
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```

#### 5.3 renderWithHooks 处理更新

```typescript
export function renderWithHooks<Props, SecondArg>(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: (p: Props, arg: SecondArg) => any,
  props: Props,
  secondArg: SecondArg,
  nextRenderLanes: Lanes,
): any {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  
  // 判断是 mount 还是 update
  if (current === null || current.memoizedState === null) {
    ReactSharedInternals.H = HooksDispatcherOnMount;
  } else {
    ReactSharedInternals.H = HooksDispatcherOnUpdate;  // 更新时使用这个
  }
  
  // 调用组件函数
  const children = Component(props, secondArg);
  
  return children;
}
```

#### 5.4 useState 更新逻辑

更新时，`useState` 会调用 `updateState`：

```typescript
function updateState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  return updateReducer(basicStateReducer, initialState);
}

function updateReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
): [S, Dispatch<A>] {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  
  // 处理更新队列
  const pending = queue.pending;
  if (pending !== null) {
    // 计算新状态
    let baseState = hook.baseState;
    let baseQueue = hook.baseQueue;
    let update = pending.next;
    
    do {
      const updateLane = update.lane;
      if (isSubsetOfLanes(renderLanes, updateLane)) {
        // 处理这个更新
        const action = update.action;
        baseState = reducer(baseState, action);  // basicStateReducer(0, 1) = 1
      }
      update = update.next;
    } while (update !== pending.next);
    
    hook.memoizedState = baseState;  // 更新为 1
    hook.baseState = baseState;
  }
  
  return [hook.memoizedState, queue.dispatch];
}
```

**关键步骤：**
1. 从 `current.memoizedState` 获取旧的 Hook 链表
2. 创建新的 Hook 对象（复用结构）
3. 处理更新队列，计算新状态：`basicStateReducer(0, 1) = 1`
4. 返回 `[1, setCount]`

### 6. 协调子节点（Reconciliation）

```typescript
function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any,
  renderLanes: Lanes,
) {
  if (current === null) {
    // mount 阶段
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // update 阶段：diff 算法
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
```

**更新时的 diff 逻辑：**
- 比较新旧 ReactElement
- 对于文本节点，如果内容改变，标记 `Update` flag
- 复用可复用的 Fiber 节点

### 7. Complete 阶段标记更新

在 Complete 阶段，会标记需要更新的节点：

```typescript
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
  
  switch (workInProgress.tag) {
    case HostText: {
      if (current !== null && workInProgress.stateNode != null) {
        const oldText = current.memoizedProps;
        const newText = newProps;
        if (oldText !== newText) {
          // 标记需要更新
          markUpdate(workInProgress);
        }
      }
      return null;
    }
  }
}
```

**标记结果：**
- 文本节点：`flags |= Update`（值为 4）
- 向上冒泡：`p.subtreeFlags |= Update`，`div.subtreeFlags |= Update`
- 最终 `App.subtreeFlags` 包含所有子树的更新标志

### 8. Commit 阶段更新 DOM

```typescript
function commitMutationEffects(
  root: FiberRoot,
  finishedWork: Fiber,
  committedLanes: Lanes,
) {
  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);
}

function commitMutationEffectsOnFiber(
  finishedWork: Fiber,
  root: FiberRoot,
  committedLanes: Lanes,
) {
  const flags = finishedWork.flags;
  
  if (flags & Update) {
    // 更新文本内容
    const textInstance = finishedWork.stateNode;
    const newText = finishedWork.memoizedProps;
    commitTextUpdate(textInstance, newText);
  }
  
  // 递归处理子节点
  if (flags & ChildDeletion) {
    commitDeletionEffects(root, finishedWork, returnFiber);
  }
}
```

**DOM 更新：**
- 找到需要更新的文本节点
- 调用 `textInstance.textContent = newText` 更新内容
- 页面显示 `count` 从 `0` 变为 `1`

---

## 流程对比总结

### 初始渲染流程
1. `createRoot` → 创建 FiberRoot 和 HostRoot Fiber
2. `root.render` → 创建更新，调度渲染
3. `prepareFreshStack` → 创建 workInProgress
4. `workLoopSync` → 深度优先遍历构建 Fiber 树
5. `beginWork` → 创建 Fiber 节点，调用组件函数
6. `completeWork` → 创建 DOM 节点（但不插入）
7. `commitRoot` → 将 DOM 插入页面

### 更新流程
1. `setCount(1)` → 创建更新对象，加入队列
2. `scheduleUpdateOnFiber` → 调度更新
3. `prepareFreshStack` → 从 current 克隆 workInProgress
4. `workLoopSync` → 重新遍历 Fiber 树
5. `beginWork` → 调用组件函数，`useState` 计算新状态
6. `reconcileChildren` → diff 算法，标记需要更新的节点
7. `completeWork` → 标记更新标志（flags）
8. `commitRoot` → 更新 DOM，页面显示新值

### 关键区别
- **初始渲染**：所有节点都是新建，`current === null`
- **更新渲染**：复用现有 Fiber，`current !== null`，通过 diff 找出变化
- **初始渲染**：`useState` 调用 `mountState`，创建 Hook
- **更新渲染**：`useState` 调用 `updateState` → `updateReducer`，处理更新队列计算新状态 